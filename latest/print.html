<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for Java Developers</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="license.html">License</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="hello-world/index.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="language/index.html"><strong aria-hidden="true">3.</strong> Language Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/data-types.html"><strong aria-hidden="true">3.1.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="language/variables-and-constants.html"><strong aria-hidden="true">3.2.</strong> Variables and Constants</a></li><li class="chapter-item expanded "><a href="language/strings.html"><strong aria-hidden="true">3.3.</strong> Strings</a></li><li class="chapter-item expanded "><a href="language/collection-types.html"><strong aria-hidden="true">3.4.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="language/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="language/control-flow.html"><strong aria-hidden="true">3.6.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="language/custom-types/index.html"><strong aria-hidden="true">3.7.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/custom-types/classes.html"><strong aria-hidden="true">3.7.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="language/custom-types/records.html"><strong aria-hidden="true">3.7.2.</strong> Records</a></li><li class="chapter-item expanded "><a href="language/custom-types/structs.html"><strong aria-hidden="true">3.7.3.</strong> Structures</a></li><li class="chapter-item expanded "><a href="language/custom-types/interfaces-and-traits.html"><strong aria-hidden="true">3.7.4.</strong> Interfaces and Traits</a></li><li class="chapter-item expanded "><a href="language/custom-types/enums.html"><strong aria-hidden="true">3.7.5.</strong> Enumerated Types</a></li><li class="chapter-item expanded "><a href="language/custom-types/members.html"><strong aria-hidden="true">3.7.6.</strong> Members</a></li></ol></li><li class="chapter-item expanded "><a href="language/lambdas-and-closures.html"><strong aria-hidden="true">3.8.</strong> Lambdas and Closures</a></li><li class="chapter-item expanded "><a href="language/streams-and-iterators.html"><strong aria-hidden="true">3.9.</strong> Streams and Iterators</a></li><li class="chapter-item expanded "><a href="language/pattern-matching.html"><strong aria-hidden="true">3.10.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="language/packages-and-modules.html"><strong aria-hidden="true">3.11.</strong> Packages and Modules</a></li><li class="chapter-item expanded "><a href="language/equality.html"><strong aria-hidden="true">3.12.</strong> Equality</a></li><li class="chapter-item expanded "><a href="language/generics.html"><strong aria-hidden="true">3.13.</strong> Generics</a></li><li class="chapter-item expanded "><a href="language/polymorphism.html"><strong aria-hidden="true">3.14.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="language/inheritance.html"><strong aria-hidden="true">3.15.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="language/error-handling.html"><strong aria-hidden="true">3.16.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="language/nullability-and-optionality.html"><strong aria-hidden="true">3.17.</strong> Nullability and Optionality</a></li><li class="chapter-item expanded "><a href="language/conversion-and-casting.html"><strong aria-hidden="true">3.18.</strong> Conversion and Casting</a></li><li class="chapter-item expanded "><a href="language/annotations.html"><strong aria-hidden="true">3.19.</strong> Annotations</a></li><li class="chapter-item expanded "><a href="language/smart-pointers.html"><strong aria-hidden="true">3.20.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="language/documentation-comments.html"><strong aria-hidden="true">3.21.</strong> Documentation Comments</a></li></ol></li><li class="chapter-item expanded "><a href="memory-management/index.html"><strong aria-hidden="true">4.</strong> Memory Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory-management/ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="memory-management/references-and-lifetimes.html"><strong aria-hidden="true">4.2.</strong> References and Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="resource-management/index.html"><strong aria-hidden="true">5.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="threading-and-concurrency/index.html"><strong aria-hidden="true">6.</strong> Threading and Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threading-and-concurrency/threads.html"><strong aria-hidden="true">6.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="threading-and-concurrency/synchronization.html"><strong aria-hidden="true">6.2.</strong> Synchronization</a></li><li class="chapter-item expanded "><a href="threading-and-concurrency/producer-consumer.html"><strong aria-hidden="true">6.3.</strong> Producer-Consumer Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">7.</strong> Testing</a></li><li class="chapter-item expanded "><a href="benchmarking/index.html"><strong aria-hidden="true">8.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="logging-and-tracing/index.html"><strong aria-hidden="true">9.</strong> Logging and Tracing</a></li><li class="chapter-item expanded "><a href="environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> Environment and Configuration</a></li><li class="chapter-item expanded "><a href="build-tools/index.html"><strong aria-hidden="true">11.</strong> Build Tools</a></li><li class="chapter-item expanded "><a href="project-structure/index.html"><strong aria-hidden="true">12.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="meta-programming/index.html"><strong aria-hidden="true">13.</strong> Meta Programming</a></li><li class="chapter-item expanded "><a href="asynchronous-programming/index.html"><strong aria-hidden="true">14.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded affix "><a href="next-steps.html">Next Steps</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for Java Developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chrischiedo/rust-for-java-devs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a high-level guide for Java developers who are
completely new to the Rust programming language. Some concepts and constructs
translate fairly well between Java and Rust, but which may be expressed
differently, whereas others are a radical departure, like memory management.
This guide provides a brief comparison and mapping of those constructs and
concepts with concise examples.</p>
<p>This work is essentially a fork of a similar open-source project by Microsoft: <a href="https://microsoft.github.io/rust-for-dotnet-devs/latest/introduction.html">Rust for C#/.NET Developers</a>.</p>
<p>This guide is not meant to be a replacement for proper learning of the Rust language via its official documentation (for example the excellent <a href="https://doc.rust-lang.org/book/">Rust book</a>). Instead, this guide should be viewed as a resource that can help answer some questions quickly, like: <em>Does Rust support inheritance, interfaces, virtual threads, etc.?</em> Or more generally, <em>how can I do X in Rust</em>? (based on your Java knowledge).</p>
<p>Assumptions:</p>
<ul>
<li>Reader is relatively comfortable with Java.</li>
<li>Reader is completely new to Rust.</li>
</ul>
<p>Goals:</p>
<ul>
<li>Provide a brief comparison and mapping of various Java topics to their
counterparts in Rust.</li>
<li>Provide links to other Rust references, books and articles for further reading on
various topics.</li>
</ul>
<p>Non-goals:</p>
<ul>
<li>Discussion of design patterns and architectures.</li>
<li>Tutorial on the Rust language.</li>
<li>Make reader proficient in Rust after reading this guide.</li>
<li>While there are short examples that contrast Java and Rust code for some
topics, this guide is not meant to be a cookbook of coding recipes in the
two languages.</li>
</ul>
<p>Here's the TLDR for a Java developer encountering Rust for the first time:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Java</th><th>Rust</th><th>Note</th></tr></thead><tbody>
<tr><td>Classes</td><td>Yes</td><td>No</td><td>See note 1.</td></tr>
<tr><td>Interfaces</td><td>Yes</td><td>No</td><td>See note 2.</td></tr>
<tr><td>Enums</td><td>Yes</td><td>Yes</td><td>See note 3.</td></tr>
<tr><td>Generics</td><td>Yes</td><td>Yes</td><td></td></tr>
<tr><td>Exceptions</td><td>Yes</td><td>No</td><td></td></tr>
<tr><td>Virtual threads</td><td>Yes</td><td>No</td><td></td></tr>
<tr><td>Asynchronous Programming</td><td>No</td><td>Yes</td><td></td></tr>
<tr><td>Garbage Collector</td><td>Yes</td><td>No</td><td>See note 4.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ol>
<li>
<p>Rust has no classes. It has structures (<code>struct</code>) instead.</p>
</li>
<li>
<p>Rust has a concept similar to interfaces called <code>Traits</code>.</p>
</li>
<li>
<p>Enums in Rust are more powerful. Rust enums are most similar to <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data types</em></a> in functional languages, such as OCaml and Haskell.</p>
</li>
<li>
<p>Rust does not have a garbage collector. Memory management is accomplished through the 
concept of <em>ownership</em>, which is arguably one of Rust's most distinctive features.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Portions Copyright © Microsoft Corporation.<br>
Portions Copyright © 2010 The Rust Project Developers.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You are invited to contribute to this guide by opening issues and
submitting pull requests!</p>
<p>Here are some ideas 💡 for how and where you can help most with
contributions:</p>
<ul>
<li>
<p>Fix any spelling or grammatical mistakes you see as you read.</p>
</li>
<li>
<p>Fix technical inaccuracies.</p>
</li>
<li>
<p>Fix logical or compilation errors in code examples.</p>
</li>
<li>
<p>Expand an explanation to provide more context or improve the clarity of some
topic or concept.</p>
</li>
<li>
<p>Keep it fresh with changes in Java and Rust. For example, if there is a
change in Java or Rust that brings the two languages closer together, then some
parts, including sample code, may need revision.</p>
</li>
</ul>
<p>If you're making a small to modest correction, such as fixing a spelling mistake or
a syntax error in a code example, then feel free to submit a pull request
directly. For changes that may require a large effort on your part (and reviewers as a result), it is strongly recommended that you submit an issue and seek approval of the author/maintainer before investing your time.</p>
<p>Making quick contributions has been made super simple. If you see an error on
a page and happen to be online, you can click the edit icon 📝 in the top right corner of
the page to edit the Markdown source of the content and submit a change.</p>
<h2 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h2>
<ul>
<li>
<p>Stick to the goals of this guide laid out in the <a href="introduction.html">introduction</a>; put another
way, avoid the non-goals!</p>
</li>
<li>
<p>Prefer to keep text short and use short, concise and realistic code examples
to illustrate a point.</p>
</li>
<li>
<p>As much as it is possible, always provide and compare examples in Rust and
Java.</p>
</li>
<li>
<p>Feel free to use latest Java/Rust language features if it makes an example
simpler, concise and alike across the two languages.</p>
</li>
<li>
<p>Make example code as self-contained as possible and runnable (unless the
idea is to illustrate a compile-time or run-time error).</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>The easiest way to get started with Rust without needing any local
installation is to use the <a href="https://play.rust-lang.org/">Rust Playground</a>. It is a minimal development
front-end that runs in the Web browser and allows writing and running Rust
code.</p>
<h2 id="dev-container"><a class="header" href="#dev-container">Dev Container</a></h2>
<p>The execution environment of the <a href="https://play.rust-lang.org/">Rust Playground</a> has some limitations, such
as total compilation/execution time, memory and networking so another
option that does not require installing Rust would be to use a <em>dev
container</em>, such as the one provided in the repository
<a href="https://github.com/microsoft/vscode-remote-try-rust">https://github.com/microsoft/vscode-remote-try-rust</a>. Like Rust Playground,
the dev container can be run directly in a Web browser using <a href="https://github.com/features/codespaces">GitHub
Codespaces</a> or <a href="https://code.visualstudio.com/docs/devcontainers/containers">locally using Visual Studio Code</a>.</p>
<h2 id="local-install"><a class="header" href="#local-install">Local Install</a></h2>
<p>For a complete local installation of Rust compiler and its development tools,
see the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Installation</a> section of the <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">Getting Started</a> chapter in the <a href="https://doc.rust-lang.org/book/title-page.html">The
Rust Programming Language</a> book, or <a href="https://www.rust-lang.org/tools/install">the Install page</a> at
<a href="https://www.rust-lang.org/">rust-lang.org</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>In keeping with the programming tradition, here's a simple <code>Hello World</code> program in Java:</p>
<pre><code class="language-java">public class HelloWorld {

    public static void main(String[] args) {
        System.out.println(&quot;Hello World.&quot;);
    }
}
</code></pre>
<p>And here's the equivalent in Rust:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello World.&quot;);
}</code></pre>
<p>A few things to note:</p>
<ul>
<li>There's much less ceremony in the Rust version of the program</li>
<li>In Rust, a function is defined using the <code>fn</code> keyword</li>
<li>In both cases, we need a <code>main</code> funtion/method as the entry point to our program</li>
<li>Unlike in Java, Rust's <code>main</code> function isn't contained in a class</li>
<li>Rust uses the <code>println!</code> <em>macro</em> to print the string to the output (notice the bang <code>!</code>)</li>
</ul>
<p>In Java's case, it's clear from the method signature that the main method returns nothing (hinted by the use of <code>void</code> as the return type).</p>
<p>Although it's not clear from the function signature, the Rust version also returns nothing. In the absense of an explicit return type, a Rust function returns void, which is represented by <code>()</code>.</p>
<p>This slightly modified Rust version works exactly the same way as the one above:</p>
<pre><code class="language-rust">fn main() -&gt; () {
    println!(&quot;Hello World.&quot;);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-features"><a class="header" href="#language-features">Language Features</a></h1>
<p>This section compares Java and Rust language features. Here's what is covered in this section:</p>
<ul>
<li><a href="language/data-types.html">Data Types</a></li>
<li><a href="language/variables-and-constants.html">Variables and Constants</a></li>
<li><a href="language/strings.html">Strings</a></li>
<li><a href="language/collection-types.html">Collection Types</a></li>
<li><a href="language/functions.html">Functions</a></li>
<li><a href="language/control-flow.html">Control Flow</a></li>
<li><a href="language/./custom-types/index.html">Custom Types</a></li>
<li><a href="language/lambdas-and-closures.html">Lambdas and Closures</a></li>
<li><a href="language/streams-and-iterators.html">Streams and Iterators</a></li>
<li><a href="language/pattern-matching.html">Pattern Matching</a></li>
<li><a href="language/packages-and-modules.html">Packages and Modules</a></li>
<li><a href="language/equality.html">Equality</a></li>
<li><a href="language/generics.html">Generics</a></li>
<li><a href="language/polymorphism.html">Polymorphism</a></li>
<li><a href="language/inheritance.html">Inheritance</a></li>
<li><a href="language/error-handling.html">Error Handling</a></li>
<li><a href="language/nullability-and-optionality.html">Nullability and Optionality</a></li>
<li><a href="language/conversion-and-casting.html">Conversion and Casting</a></li>
<li><a href="language/annotations.html">Annotations</a></li>
<li><a href="language/smart-pointers.html">Smart Pointers</a></li>
<li><a href="language/documentation-comments.html">Documentation Comments</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>The following table lists the primitive types in Rust and their equivalent in Java:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Java</th><th>Java Wrapper Class</th><th>Note</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>boolean</code></td><td><code>Boolean</code></td><td></td></tr>
<tr><td><code>char</code></td><td><code>char</code></td><td><code>Character</code></td><td>See note 1.</td></tr>
<tr><td><code>i8</code></td><td><code>byte</code></td><td><code>Byte</code></td><td></td></tr>
<tr><td><code>i16</code></td><td><code>short</code></td><td><code>Short</code></td><td></td></tr>
<tr><td><code>i32</code></td><td><code>int</code></td><td><code>Integer</code></td><td>See note 2.</td></tr>
<tr><td><code>i64</code></td><td><code>long</code></td><td><code>Long</code></td><td></td></tr>
<tr><td><code>i128</code></td><td></td><td></td><td></td></tr>
<tr><td><code>isize</code></td><td></td><td></td><td>See note 3.</td></tr>
<tr><td><code>u8</code></td><td></td><td></td><td></td></tr>
<tr><td><code>u16</code></td><td></td><td></td><td></td></tr>
<tr><td><code>u32</code></td><td></td><td></td><td></td></tr>
<tr><td><code>u64</code></td><td></td><td></td><td></td></tr>
<tr><td><code>u128</code></td><td></td><td></td><td></td></tr>
<tr><td><code>usize</code></td><td></td><td></td><td>See note 3.</td></tr>
<tr><td><code>f32</code></td><td><code>float</code></td><td><code>Float</code></td><td></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td><td><code>Double</code></td><td></td></tr>
<tr><td><code>()</code></td><td><code>void</code></td><td><code>Void</code></td><td>See note 4.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ol>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a> in Rust and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html"><code>Character</code></a> in JVM have different
definitions. In Rust, a <code>char</code> is 4 bytes wide that is a <a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar
value</a>, but in the Java Platform, a <code>Character</code> is 2 bytes wide (16-bit fixed-width) and stores the character
using the UTF-16 encoding. For more information, see the <a href="https://doc.rust-lang.org/std/primitive.char.html">Rust <code>char</code>
documentation</a>.</p>
</li>
<li>
<p>Unlike Java (and like C/C++/C#), Rust makes a distinction between signed and unsigned
integer types. While all integral types in Java represent <em>signed</em> numbers, Rust provides both <em>signed</em> (e.g. <code>i32</code>) and <em>unsigned</em> (e.g. <code>u32</code>) integer types.</p>
</li>
<li>
<p>Rust also provides the <code>isize</code> and <code>usize</code> types that depend on the architecture of the
machine your program is running on: 64 bits if you're on a 64-bit architecture and 32 bits
if you're on a 32-bit architecture.</p>
</li>
<li>
<p>While a unit <code>()</code> (an empty tuple) in Rust is an <em>expressible value</em>, the
closest cousin in Java would be <code>void</code> to represent nothing.</p>
</li>
</ol>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/primitives.html">Primitives (Rust By Example)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-constants"><a class="header" href="#variables-and-constants">Variables and Constants</a></h1>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Consider the following example around variable assignment in Java:</p>
<pre><code class="language-java">int x = 5;
</code></pre>
<p>And the same in Rust:</p>
<pre><code class="language-rust">let x: i32 = 5;</code></pre>
<p>So far, the only visible difference between the two languages is that the
position of the type declaration is different. Also, both Java and Rust are
type-safe: the compiler guarantees that the value stored in a variable is always
of the designated type. The example can be simplified by using the compiler's
ability to automatically infer the types of the variable. In Java:</p>
<pre><code class="language-java">// Note: this applies only to local variables, i.e. those declared within a method
var x = 5; // type inferred as int
</code></pre>
<p>In Rust:</p>
<pre><code class="language-rust">let x = 5; // type inferred as i32</code></pre>
<p>When expanding the first example to update the value of the variable
(reassignment), the behavior of Java and Rust differ:</p>
<pre><code class="language-java">var x = 5;
x = 6;
System.out.println(x); // 6
</code></pre>
<p>In Rust, the identical statement will not compile:</p>
<pre><code class="language-rust">let x = 5;
x = 6; // Error: cannot assign twice to immutable variable 'x'.
println!(&quot;{}&quot;, x);</code></pre>
<p>In Rust, variables are <em>immutable</em> by default. Once a value is bound to a name,
the variable's value cannot be changed. Variables can be made <em>mutable</em> by
adding <a href="https://doc.rust-lang.org/std/keyword.mut.html"><code>mut</code></a> in front of the variable name:</p>
<pre><code class="language-rust">let mut x = 5;
x = 6;
println!(&quot;{}&quot;, x); // 6</code></pre>
<p>Rust offers an alternative to fix the example above that does not require
mutability through variable <em>shadowing</em>:</p>
<pre><code class="language-rust">let x = 5;
let x = 6;
println!(&quot;{}&quot;, x); // 6</code></pre>
<p>Java also supports shadowing, e.g. locals can shadow fields and type members can
shadow members from the base type. In Rust, the above example demonstrates
that shadowing also allows to change the type of a variable without changing
the name, which is useful if one wants to transform the data into different
types and shapes without having to come up with a distinct name each time.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>In Java, a constant is a <code>static final</code> field:</p>
<pre><code class="language-java">static final double GOLDEN_RATIO = 1.618034;
</code></pre>
<p>The same in Rust looks like this:</p>
<pre><code class="language-rust">const GOLDEN_RATIO: f64 = 1.618034;</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/races.html">Data races and race conditions</a> for more information around the implications
of mutability</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/variable_bindings/scope.html#scope-and-shadowing">Scope and shadowing</a></li>
<li><a href="language/../memory-management/index.html">Memory management</a> for explanations around
<em>moving</em> and <em>ownership</em></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/custom_types/constants.html">Constants in Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>There are two string types in Rust: <code>String</code> and <code>&amp;str</code>. The former is
allocated on the heap and the latter is a slice of a <code>String</code> or a <code>&amp;str</code>.</p>
<p>The mapping of those to Java is shown in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Java</th><th>Note</th></tr></thead><tbody>
<tr><td><code>&amp;str</code></td><td><code>String</code></td><td>see Note 1.</td></tr>
<tr><td><code>Box&lt;str&gt;</code></td><td><code>String</code></td><td>see Note 2.</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td></td></tr>
<tr><td><code>String</code> (mutable)</td><td><code>StringBuilder</code></td><td>see Note 2.</td></tr>
</tbody></table>
</div>
<p>There are differences in working with strings in Rust and Java, but the
equivalents above should be a good starting point. One of the differences is
that Rust strings are UTF-8 encoded, but JVM strings are UTF-16 encoded.
Further JVM strings are immutable, but Rust strings can be mutable when declared
as such, for example <code>let s = &amp;mut String::from(&quot;hello&quot;);</code>.</p>
<p>There are also differences in using strings due to the concept of ownership. To
read more about ownership with the String Type, see the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-string-type">Rust book</a>.</p>
<p>Notes:</p>
<ol>
<li>
<p>In Rust, <code>&amp;str</code> (pronounced: <em>string slice</em>) is an immutable string reference type.</p>
</li>
<li>
<p>The <code>Box&lt;str&gt;</code> type in Rust is equivalent to the <code>String</code> type in JVM. The
difference between the <code>Box&lt;str&gt;</code> and <code>String</code> types in Rust is that the
former stores pointer and size while the latter stores pointer, size, and
capacity, allowing <code>String</code> to grow in size. This is similar to the
<code>StringBuilder</code> type in JVM once the Rust <code>String</code> is declared mutable.</p>
</li>
</ol>
<p>Java:</p>
<pre><code class="language-java">String str = &quot;Hello, World!&quot;;

StringBuilder sb1 = new StringBuilder(&quot;Hello, World!&quot;);

StringBuilder sb2 = new StringBuilder();
sb2.append(&quot;Hello&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let str1: &amp;str = &quot;Hello, World!&quot;;
let str2 = Box::new(&quot;Hello World!&quot;);

let mut sb1 = String::from(&quot;Hello World!&quot;);

let mut sb2 = String::new();
sb2.push_str(&quot;Hello&quot;);</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h2>
<p>String literals in Java are immutable <code>String</code> types and allocated on the heap.
In Rust, they are <code>&amp;'static str</code>, which is immutable and has a global lifetime
and does not get allocated on the heap; they're embedded in the compiled binary.</p>
<p>Java</p>
<pre><code class="language-java">String str = &quot;Hello, World!&quot;;
</code></pre>
<p>Rust</p>
<pre><code class="language-rust">let str: &amp;'static str = &quot;Hello, World!&quot;;</code></pre>
<p>Unlike Java, Rust can represent verbatim string literals as raw string literals.</p>
<p>Rust</p>
<pre><code class="language-rust">let str = r#&quot;Hello, \World/!&quot;#;</code></pre>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>Java lacks native support for String interpolation<sup class="footnote-reference"><a href="#interpolation">1</a></sup> in comparison to languages like <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">C#</a>. The most common way of implementing string interpolation in Java is by using the <code>format()</code> method from the <code>String</code> class. Here's an example:</p>
<pre><code class="language-java">String name = &quot;John&quot;;
int age = 42;
String result = String.format(&quot;Person { Name: %s, Age: %d }&quot;, name, age);

// Alternative using the '+' operator
String result2 = &quot;Person { Name: &quot; + name + &quot;, Age: &quot; + age + &quot; }&quot;;
</code></pre>
<p>Like Java, Rust does not have a built-in string interpolation feature. Instead, the
<code>format!</code> macro is used to format a string. The following example shows how to
use string interpolation in Rust:</p>
<pre><code class="language-rust">let name = &quot;John&quot;;
let age = 42;
let result = format!(&quot;Person {{ name: {name}, age: {age} }}&quot;);</code></pre>
<p>Custom types can also be interpolated in Java due to the fact that
the <code>toString()</code> method is available for each type as it's inherited from <code>Object</code>.</p>
<pre><code class="language-java">public class Person {
    private String name;
    private int age;

    // getters and setters omitted

    @Override
    public String toString() {
        return String.format(&quot;Person { Name: %s, Age: %d }&quot;, name, age);
    }
}

// Calling from main method
Person person = new Person();
person.setName(&quot;John&quot;);
person.setAge(42);
System.out.println(person);
</code></pre>
<p>In Rust, there is no default formatting implemented/inherited for each type.
Instead, the <code>std::fmt::Display</code> trait must be implemented for each type that
needs to be converted to a string.</p>
<pre><code class="language-rust">use std::fmt::*;

struct Person {
    name: String,
    age: i32,
}

impl Display for Person {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, &quot;Person {{ name: {}, age: {} }}&quot;, self.name, self.age)
    }
}

let person = Person {
    name: &quot;John&quot;.to_owned(),
    age: 42,
};

println!(&quot;{person}&quot;);</code></pre>
<p>Another option is to use the <code>std::fmt::Debug</code> trait. The <code>Debug</code> trait is
implemented for all standard types and can be used to print the internal
representation of a type. The following example shows how to use the <code>derive</code>
attribute to print the internal representation of a custom struct using the
<code>Debug</code> macro. This declaration is used to automatically implement the <code>Debug</code>
trait for the <code>Person</code> struct:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: i32,
}

let person = Person {
    name: &quot;John&quot;.to_owned(),
    age: 42,
};

println!(&quot;{person:?}&quot;);</code></pre>
<blockquote>
<p>Note: Using the :? format specifier will use the <code>Debug</code> trait to print the
struct, where leaving it out will use the <code>Display</code> trait.</p>
</blockquote>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/hello/print/print_debug.html?highlight=derive#debug">Rust by Example - Debug</a></li>
</ul>
<hr />
<div class="footnote-definition" id="interpolation"><sup class="footnote-definition-label">1</sup>
<p>Java now has <a href="https://openjdk.org/jeps/430">String Templates</a> as a preview feature in Java 21 and Java 22.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h1>
<p>Commonly used collection types in Rust and their mapping to Java:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Java</th><th>Java Interface</th><th>Note</th></tr></thead><tbody>
<tr><td><code>Array</code></td><td><code>Array</code></td><td></td><td>see Note 1.</td></tr>
<tr><td><code>Vec</code></td><td><code>ArrayList</code></td><td><code>List</code></td><td></td></tr>
<tr><td><code>HashMap</code></td><td><code>HashMap</code></td><td><code>Map</code></td><td></td></tr>
<tr><td><code>HashSet</code></td><td><code>HashSet</code></td><td><code>Set</code></td><td></td></tr>
<tr><td><code>Tuple</code></td><td></td><td></td><td>see Note 2.</td></tr>
<tr><td><code>LinkedList</code></td><td><code>LinkedList</code></td><td><code>List</code></td><td>see Note 3.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ol>
<li>
<p>Java provides the <code>Arrays</code> utility class for manipulating arrays.</p>
</li>
<li>
<p>Unlike Rust, Java does not have the <code>Tuple</code> type.</p>
</li>
<li>
<p>In both Rust and Java the <code>LinkedList</code> collection is implemented using a doubly-linked
list.</p>
</li>
</ol>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Fixed arrays are supported the same way in Rust and Java.</p>
<p>Java:</p>
<pre><code class="language-java">int[] someArray = new int[] { 1, 2 };
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let some_array: [i32; 2] = [1,2];</code></pre>
<p>Notice the type of <code>some_array</code>: <code>[T; N]</code> - it indicates both the type of elements of the array and the size of the array (which is fixed at compile time).</p>
<p>Accessing array elements is similar in both languages:</p>
<p>Java:</p>
<pre><code class="language-java">int firstElement = someArray[0];
int secondElement = someArray[1];

System.out.println(firstElement);  // prints: 1
System.out.println(secondElement); // prints: 2
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let first_element = some_array[0];
let second_element = some_array[1];

println!(&quot;{}&quot;, first_element);  // prints: 1
println!(&quot;{}&quot;, second_element); // prints: 2</code></pre>
<h2 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h2>
<p>In Rust, the equivalent of Java's <code>ArrayList&lt;E&gt;</code> is <code>Vec&lt;T&gt;</code>. Arrays can be converted
to Vecs and vice versa.</p>
<p>Java:</p>
<pre><code class="language-java">List&lt;String&gt; someList = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;));

someList.add(&quot;c&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut some_list = vec![
    &quot;a&quot;.to_owned(),
    &quot;b&quot;.to_owned()
];

some_list.push(&quot;c&quot;.to_owned());</code></pre>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>In both Rust and Java, a HashMap is represented as <code>HashMap&lt;K, V&gt;</code>.</p>
<p>Java:</p>
<pre><code class="language-java">Map&lt;String, String&gt; someMap = new HashMap&lt;&gt;(Map.of(&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Qux&quot;));

someMap.put(&quot;hi&quot;, &quot;there&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut some_map = HashMap::from([
    (&quot;Foo&quot;.to_owned(), &quot;Bar&quot;.to_owned()),
    (&quot;Baz&quot;.to_owned(), &quot;Qux&quot;.to_owned())
]);

some_map.insert(&quot;hi&quot;.to_owned(), &quot;there&quot;.to_owned());</code></pre>
<h2 id="hashset"><a class="header" href="#hashset">HashSet</a></h2>
<p>In Rust, the equivalent of Java's <code>HashSet&lt;E&gt;</code> is <code>HashSet&lt;T&gt;</code>.</p>
<p>Java:</p>
<pre><code class="language-java">Set&lt;String&gt; someSet = new HashSet&lt;&gt;(Set.of(&quot;a&quot;, &quot;b&quot;));

someSet.add(&quot;c&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut some_set = HashSet::from([&quot;a&quot;.to_owned(), &quot;b&quot;.to_owned()]);

some_set.insert(&quot;c&quot;.to_owned());</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/collections/index.html">Rust's standard library - Collections</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Unlike in Java where methods are mainly used to add behaviour to types (and therefore are tied to those types), Rust supports stand-alone functions. Rust <em>also</em> supports methods (and <em>associated</em> functions) that are tied to types (<code>structs</code> and <code>enums</code>).</p>
<p>Consider the following example method in Java:</p>
<pre><code class="language-java">// A method to calculate the area of a rectangle
double areaOfRectangle(double length, double width) {
    return length * width;
}
</code></pre>
<p>This is how the equivalent function looks like in Rust:</p>
<pre><code class="language-rust">// A function to calculate the area of a rectangle
fn area_of_rectangle(length: f64, width: f64) -&gt; f64 {
	length * width // No semi-colon needed here. The expression is evaluated and the result returned
}</code></pre>
<p>This would still work but it's not <em>idiomatic</em> Rust:</p>
<pre><code class="language-rust">fn area_of_rectangle(length: f64, width: f64) -&gt; f64 {
	return length * width; // using a return statement works, but it's not idiomatic Rust
}</code></pre>
<p>Here are a few things to note:</p>
<ul>
<li>In Rust, functions are defined with <code>fn</code>.</li>
<li>Rust uses <code>snake_case</code> for function names (and for variable names as well).</li>
<li>Unlike in Java, types are declared second in Rust (<code>length: f64</code>).</li>
<li>In Rust, <code>-&gt;</code> signifies the return type of a function.</li>
<li>In Rust, the <em>idiomatic way</em> to return from a function is to <em>not</em> terminate with 
semi-colon.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Like Java, Rust has control flow constructs like <code>if</code> expressions, <code>while</code> and <code>for</code> loops. </p>
<p>Consider the following code snippet in Java:</p>
<pre><code class="language-java">int number = 50;

if (number % 3 == 0) {
    System.out.println(&quot;fizz&quot;);
} else if (number % 5 == 0) {
    System.out.println(&quot;buzz&quot;);
} else {
    System.out.println(&quot;nothing special...&quot;);
}
</code></pre>
<p>This is the equivalent in Rust:</p>
<pre><code class="language-rust">let number = 50;

if number % 3 == 0 {
    println!(&quot;fizz&quot;);
} else if number % 5 == 0 {
    println!(&quot;buzz&quot;);
} else {
    println!(&quot;nothing special...&quot;);
}</code></pre>
<p>Notice that in Rust we don't have parenthesis around the condition, like in Java.</p>
<p>Consider the following <code>while</code> loop in Java:</p>
<pre><code class="language-java">int number = 10;

while (number &gt; 0) {
    System.out.println(number);
    number--; // or number = number - 1; or number -= 1;
}
</code></pre>
<p>This is the equivalent in Rust:</p>
<pre><code class="language-rust">let mut number = 10;

while number &gt; 0 {
    println!(&quot;{}&quot;, number);
    number -= 1; // or number = number - 1;
}</code></pre>
<p>Note that <code>number--</code> doesn't work in Rust. Also, <code>number</code> is declared as <code>mut</code>.</p>
<h2 id="looping-through-a-collection-with-for"><a class="header" href="#looping-through-a-collection-with-for">Looping through a collection with <code>for</code></a></h2>
<p>Java supports two types of <code>for</code> loops:</p>
<ul>
<li>The traditional C-style <code>for</code> loop</li>
<li>The enhanced <code>for</code> loop (also known as <code>for-each</code> loop)</li>
</ul>
<p>Consider the following Java example that uses C-style <code>for</code> loop:</p>
<pre><code class="language-java">int[] numbers = { 10, 20, 30, 40, 50 };

for (int i = 0; i &lt; numbers.length; i++) {
    System.out.println(numbers[i]);
}
</code></pre>
<p>Rust does not support C-style <code>for</code> loops. But we can get the same results using the 
<code>range</code> syntax:</p>
<pre><code class="language-rust">let numbers = [10, 20, 30, 40, 50];
    
for i in 0..numbers.len() {
    println!(&quot;{}&quot;, numbers[i]);
}</code></pre>
<p>Here's how we can use the enhanced <code>for</code> loop in Java:</p>
<pre><code class="language-java">int[] numbers = { 10, 20, 30, 40, 50 };

for (int number : numbers) {
    System.out.println(number);
}
</code></pre>
<p>Here's the equivalent in Rust:</p>
<pre><code class="language-rust">let numbers = [10, 20, 30, 40, 50];
    
for number in numbers {
    println!(&quot;{}&quot;, number);
}</code></pre>
<h2 id="defining-infinite-loops"><a class="header" href="#defining-infinite-loops">Defining infinite loops</a></h2>
<p>There are a few ways of defining infinite loops in Java. We'll consider two:</p>
<ol>
<li>Using <code>while</code>:</li>
</ol>
<pre><code class="language-java">while (true) {
    // do something
}
</code></pre>
<ol start="2">
<li>Using <code>for</code>:</li>
</ol>
<pre><code class="language-java">for (;;) {
    // do something
}
</code></pre>
<p>Here's how you would define an infinite loop in Rust:</p>
<pre><code class="language-rust">loop {
    // do something
}</code></pre>
<p>Both Java and Rust support <code>break</code> and <code>continue</code> statements that can be used to break out of loops.</p>
<h2 id="the-ternary-operator-in-java"><a class="header" href="#the-ternary-operator-in-java">The ternary operator in Java</a></h2>
<p>Consider the following trivial method in Java:</p>
<pre><code class="language-java">String getResult(int score) {
    return score &gt;= 70 ? &quot;pass&quot; : &quot;fail&quot;; // using ternary operator
}

System.out.println(getResult(60)); // prints: fail
System.out.println(getResult(80)); // prints: pass
</code></pre>
<p>An equivalent version in Rust would look like this:</p>
<pre><code class="language-rust">fn get_result(score: i32) -&gt; String {
	let result = if score &gt;= 70 { &quot;pass&quot; } else { &quot;fail&quot; }; // result has type &amp;str
	return result.to_string();
}

fn main() {
	println!(&quot;{}&quot;, get_result(60)); // prints: fail
	println!(&quot;{}&quot;, get_result(80)); // prints: pass
}</code></pre>
<p>An alternative way of writing the Rust function is shown below:</p>
<pre><code class="language-rust">fn get_result(score: i32) -&gt; String {
	if score &gt;= 70 { &quot;pass&quot;.to_string() } else { &quot;fail&quot;.to_string() }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<p>This sub-section discusses various topics and constructs related to developing custom types. Here's what is covered:</p>
<ul>
<li><a href="language/custom-types/classes.html">Classes</a></li>
<li><a href="language/custom-types/records.html">Records</a></li>
<li><a href="language/custom-types/structs.html">Structures</a></li>
<li><a href="language/custom-types/interfaces.html">Interfaces</a></li>
<li><a href="language/custom-types/enums.html">Enumerated Types</a></li>
<li><a href="language/custom-types/members.html">Members</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>Rust does not have classes. It has <a href="language/custom-types/structs.html">structures or <code>struct</code></a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>Rust does not have records. In Java, records (or <code>record classes</code>) were added as a stable feature in Java 16.</p>
<p>A Rust constuct that would be considered (approximately) similar to records would be <a href="language/custom-types/structs.html">structures or <code>struct</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures-struct"><a class="header" href="#structures-struct">Structures (<code>struct</code>)</a></h1>
<p>Structures in Rust, defined with the <code>struct</code> keyword, resemble <code>struct</code> types in C/C++. In Java, the struct type can be approximated using a <code>record</code> class (when used as a &quot;<em>data carrier</em>&quot;). Here's a high-level comparison between Rust structs and Java record classes:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust structs</th><th>Java records</th></tr></thead><tbody>
<tr><td>They are allocated on the stack by default.</td><td>Being reference types, they are allocated on the heap by default.</td></tr>
<tr><td>A struct can implement multiple traits.</td><td>A record can implement multiple interfaces.</td></tr>
<tr><td>Structs cannot be sub-classed.</td><td>Records cannot be sub-classed/extended.</td></tr>
<tr><td>Methods for a struct are defined separately in an <em>implementation block</em> (<code>impl</code>).</td><td>Just like normal classes in Java, a record class can have methods.</td></tr>
</tbody></table>
</div>
<p>In Java, a <code>record class</code> is a way to model an <em>immutable data</em> carrier. In
Rust, a <code>struct</code> is the primary construct for modeling any data structure (the
other being an <code>enum</code>). This means that we can also use a normal Java class (with some modifications) to represent a Rust struct.</p>
<p>Here's a simple example of a <code>struct</code> in Rust:</p>
<pre><code class="language-rust">struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // creating an instance of Point struct
    let p = Point {
        x: 10.5, 
        y: 12.4,
    };

    println!(&quot;Value of x is: {}&quot;, p.x);
    println!(&quot;Value of y is: {}&quot;, p.y);
}</code></pre>
<p>Here's the equivalent in Java:</p>
<pre><code class="language-java">record Point(double x, double y) {}

// creating an instance of Point
Point p = new Point(10.5, 12.4);

System.out.println(&quot;Value of x is: &quot; + p.x());
System.out.println(&quot;Value of y is: &quot; + p.y());
</code></pre>
<p>A <code>record</code> class (or a normal <code>class</code>) in Java has object equality and copy semantics by default. And so you are able to do things like this out of the box: </p>
<pre><code class="language-java">Point p1 = new Point(10.5, 12.4);
Point p2 = new Point(10.5, 12.4);
Point p3 = p1;
Point p4 = new Point(8.5, 14.8);

System.out.println(p1 == p2);      // false
System.out.println(p1.equals(p2)); // true
System.out.println(p1 == p3);      // true
System.out.println(p3.equals(p4)); // false
</code></pre>
<p>In Rust on the other hand, you need to annotate the struct with the
<a href="https://doc.rust-lang.org/stable/reference/attributes/derive.html"><code>#derive</code> attribute</a> and list the traits to be implemented:</p>
<pre><code class="language-rust">#[derive(Copy,      // enables copy-by-value semantics
         Clone,     // required by Copy
         PartialEq, // enables value equality (==)
         Eq,        // stricter version of PartialEq
         Hash       // enables hash-ability for use in map types
)]
struct Point {
    x: f64,
    y: f64,
}</code></pre>
<p>Consider the following <code>record</code> representing a rectangle in Java:</p>
<pre><code class="language-java">record Rectangle(double length, double width) {

    // Constructor. Please see Note 1.
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    // Accessor method. Please see Note 2.
    public double length() {
        return length;
    }

    // Accessor method. Please see Note 2.
    public double width() {
        return width;
    }

    // Static method
    public static double area(double length, double width) {
         return length * width;
    }

    @Override
    public String toString() {
        return &quot;Rectangle with length: &quot; + length + &quot; and width: &quot; + width + &quot; has been created.&quot;;
    }
}
</code></pre>
<p>Notes:</p>
<ol>
<li>
<p>This is strictly not necessary. Added for the sake of comparison with the
Rust version.</p>
</li>
<li>
<p>Having the accessor methods is strictly not necessary. Added for the sake of comparison with the Rust version.</p>
</li>
</ol>
<p>The equivalent in Rust would be:</p>
<pre><code class="language-rust">#![allow(dead_code)]

use std::fmt::*;

struct Rectangle {
    length: f64,
    width: f64,
}

impl Rectangle {
    pub fn new(length: f64, width: f64) -&gt; Self {
        Self { length, width }
    }

    pub fn length(&amp;self) -&gt; f64 {
        self.length
    }

    pub fn width(&amp;self)  -&gt; f64 {
        self.width
    }

    pub fn area(&amp;self)  -&gt; f64 {
        self.length() * self.width()
    }
}

impl Display for Rectangle {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, &quot;Rectangle with length: {}, and width: {} has been created.&quot;, self.length, self.width)
    }
}</code></pre>
<p>Note that a <code>record</code> in Java inherits the <code>toString()</code> method from the <code>Record</code> class (which extends <code>Object</code>) and
therefore it <em>overrides</em> the base implementation to provide a custom string
representation. Since there is no inheritance in Rust, the way a type
advertises support for some <em>formatted</em> representation is by implementing the
<code>Display</code> trait. This then enables an instance of the struct to
participate in formatting, such as shown in the call to <code>println!</code> below:</p>
<pre><code class="language-rust">fn main() {
    let rect = Rectangle::new(5.2, 4.8);
    println!(&quot;{rect}&quot;); // Will print: Rectangle with length: 5.2, and width: 4.8 has been created.
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces-and-traits"><a class="header" href="#interfaces-and-traits">Interfaces and Traits</a></h1>
<p>Rust doesn't have interfaces like those found in Java. It has <em>traits</em>,
instead. Similar to an interface, a trait represents an abstraction and its
members form a contract that must be fulfilled when implemented on a type.</p>
<p>Here's a simple example of an <code>interface</code> in Java:</p>
<pre><code class="language-java">interface Scalable {
	double scaleLength();
	double scaleWidth();
}
</code></pre>
<p>Here's the equivalent <code>trait</code> definition in Rust:</p>
<pre><code class="language-rust">trait Scalable {
    fn scale_length(&amp;self) -&gt; f64;
    fn scale_width(&amp;self) -&gt; f64;
}</code></pre>
<p>In Java, the <code>Rectangle</code> record (from the previous section on <a href="language/custom-types/./structs.html">structs</a>) can implement the <code>Scalable</code> interface as follows:</p>
<pre><code class="language-java">record Rectangle(double length, double width) implements Scalable {
	
	// details from previous section omitted

	@Override
    public double scaleLength() {
        return length * 2;
    }

    @Override
    public double scaleWidth() {
        return width * 2;
    }
}
</code></pre>
<p>In Rust, the <code>Rectangle</code> struct (from the previous section on <a href="language/custom-types/./structs.html">structs</a>) can implement the
<code>Scalable</code> trait as follows:</p>
<pre><code class="language-rust">impl Scalable for Rectangle {
    fn scale_length(&amp;self) -&gt; f64 {
        self.length * 2 as f64
    }
    
    fn scale_width(&amp;self) -&gt; f64 {
        self.width * 2 as f64
    }
}</code></pre>
<p>Note that in the previous section on <a href="language/custom-types/./structs.html">structs</a>, we implemented the <code>Display</code> trait for the Rectangle struct. Here's how the <code>Display</code> trait is declared:</p>
<pre><code class="language-rust">pub trait Display {
    // Required method
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>Just the way interfaces can have default methods<sup class="footnote-reference"><a href="#default">1</a></sup> in Java (where a default
implementation body is provided as part of the interface definition), so can
traits in Rust. The type implementing the interface/trait can subsequently
provide a more suitable and/or optimized implementation if needed.</p>
<p>Also, just like in Java interfaces, traits in Rust can define static methods<sup class="footnote-reference"><a href="#static">2</a></sup> (and even constants). Technically, in Rust these are called <em>associated</em> functions and constants.</p>
<h2 id="extending-interfaces-and-traits"><a class="header" href="#extending-interfaces-and-traits">Extending Interfaces and Traits</a></h2>
<p>In Java, an interface can extend another interface. Let's say we have an interface called <code>Shape</code> that's declared as follows:</p>
<pre><code class="language-java">interface Shape {
	// default method
	default boolean isRectangular() {
		return true;
	}
}
</code></pre>
<p>The <code>Scalable</code> interface can then extend the <code>Shape</code> interface, like so:</p>
<pre><code class="language-java">interface Scalable extends Shape {
	double scaleLength();
	double scaleWidth();
}
</code></pre>
<p>The <code>Rectangle</code> record that implements the <code>Scalable</code> interface now has access to the default method defined in the <code>Shape</code> interface as well.</p>
<pre><code class="language-java">record Rectangle(double length, double width) implements Scalable {
	
	// you have access to the default method defined in the Shape interface.
}
</code></pre>
<p>Similar behaviour can be achieved in Rust using <code>supertraits</code> and <code>subtraits</code>. Here's the <code>Shape</code> trait:</p>
<pre><code class="language-rust">trait Shape {
	// default method
    fn is_rectangular(&amp;self) -&gt; bool {
    	true
    }
}</code></pre>
<p>The <code>Scalable</code> trait can then extend the <code>Shape</code> trait, like so:</p>
<pre><code class="language-rust">trait Scalable: Shape {
    fn scale_length(&amp;self) -&gt; f64;
    fn scale_width(&amp;self) -&gt; f64;
}</code></pre>
<p>In this case, <code>Shape</code> is the <em>supertrait</em> while <code>Scalable</code> is the <em>subtrait</em>.</p>
<p>Now, any type that implements the <code>Scalable</code> trait must also implement the <code>Shape</code> trait as well (note that this is slightly different from the Java case with interfaces).</p>
<p>Here's the <code>Rectangle</code> struct from the previous section on <a href="language/custom-types/./structs.html">structs</a>.</p>
<pre><code class="language-rust">#![allow(dead_code)]

use std::fmt::*;

struct Rectangle {
    length: f64,
    width: f64,
}

impl Rectangle {
    // details from previous section omitted
}

impl Scalable for Rectangle {
    fn scale_length(&amp;self) -&gt; f64 {
        self.length * 2 as f64
    }
    
    fn scale_width(&amp;self) -&gt; f64 {
        self.width * 2 as f64
    }
}

impl Shape for Rectangle {}
</code></pre>
<p>We can now invoke the default method defined in the <code>Shape</code> trait as shown below:</p>
<pre><code class="language-rust">fn main() {
    let rect = Rectangle::new(5.2, 4.8);

    println!(&quot;The Shape is a Rectangle: {}&quot;, rect.is_rectangular()); // Will print: The Shape is a Rectangle: true
}</code></pre>
<h2 id="marker-interfaces-and-traits"><a class="header" href="#marker-interfaces-and-traits">Marker Interfaces and Traits</a></h2>
<p>Rust has marker traits, just like Java has marker interfaces. These are empty (no methods declared) traits/interfaces; their main purpose being to communicate certain type behaviour to the compiler.</p>
<p><code>Cloneable</code> is an example of a marker interface in Java:</p>
<pre><code class="language-java">public interface Cloneable { }
</code></pre>
<p><code>Copy</code> is an example of a marker trait in Rust:</p>
<pre><code class="language-rust">pub trait Copy: Clone { }</code></pre>
<p>Notice how the <code>Copy</code> trait extends the <code>Clone</code> trait.</p>
<h2 id="polymorphic-behaviour"><a class="header" href="#polymorphic-behaviour">Polymorphic Behaviour</a></h2>
<p>Apart from class hierarchies, interfaces are a core means of achieving
<em>polymorphism</em> via dynamic dispatch for cross-cutting abstractions. They enable
general-purpose code to be written against the abstractions represented by the
interfaces without much regard to the concrete types implementing them.</p>
<p>Since Rust doesn't have classes and consequently type hierarchies based on sub-classing, polymorphism can be achieved using <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a> (in a limited fashion). A trait
object is essentially a <em>v-table</em> (virtual table) identified with the <code>dyn</code>
keyword followed by the trait name, as in <code>dyn Shape</code> (where <code>Shape</code> is the
trait name). Trait objects always live behind a pointer, either a reference
(e.g. <code>&amp;dyn Shape</code>) or the heap-allocated <code>Box</code> (e.g. <code>Box&lt;dyn Shape&gt;</code>). This
is somewhat like in Java, where an interface is a reference type such that a
type cast to an interface is automatically boxed onto the managed heap.</p>
<p>One limitation of trait objects is that the original
implementing type cannot be recovered. In other words, whereas it's quite
common to downcast or test an interface to be an instance of some other
interface or sub- or concrete type, the same is not possible in Rust (without
additional effort and support).</p>
<hr />
<div class="footnote-definition" id="default"><sup class="footnote-definition-label">1</sup>
<p>Default methods in interfaces were introduced in Java 8.
<sup class="footnote-reference"><a href="#static">2</a></sup>: Static methods in interfaces were introduced in Java 8.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerated-types-enum"><a class="header" href="#enumerated-types-enum">Enumerated types (<code>enum</code>)</a></h1>
<p>In Java, an <code>enum</code> is a specialized type of class that has limited functionality. An enum holds a small number of possible permissible values of a type.</p>
<p>Here's an example of an enum in Java:</p>
<pre><code class="language-java">enum PrimaryColor {
    RED,
    GREEN,
    BLUE
}
</code></pre>
<p>Rust has an identical syntax for declaring the same enum:</p>
<pre><code class="language-rust">enum PrimaryColor {
    Red,
    Green,
    Blue
}</code></pre>
<p>Being specialized classes in Java, enums can have member fields and methods. Here's an example for illustration purposes:</p>
<pre><code class="language-java">enum RainbowColor {

    RED(1),
    ORANGE(2),
    YELLOW(3),
    GREEN(4),
    BLUE(5),
    INDIGO(6),
    VIOLET(7); // the semi colon at the end of list required for enums with parameters

    private final int number;
    private final String name;

    public int getNumber() {
        return number;
    }

    public String getName() {
        return name;
    }

    RainbowColor(int number) {
        this.number = number;
        this.name = switch (number) {
            case 1 -&gt; &quot;RED&quot;;
            case 2 -&gt; &quot;ORANGE&quot;;
            case 3 -&gt; &quot;YELLOW&quot;;
            case 4 -&gt; &quot;GREEN&quot;;
            case 5 -&gt; &quot;BLUE&quot;;
            case 6 -&gt; &quot;INDIGO&quot;;
            case 7 -&gt; &quot;VIOLET&quot;;
            default -&gt; throw new RuntimeException(&quot;Illegal: &quot; + number);
        };
    }
}
</code></pre>
<p>Here's how we could exercise the <code>RainbowColor</code> enum:</p>
<pre><code class="language-java">public class RainbowColorTest {

    public static void main(String[] args) {
        RainbowColor color = RainbowColor.BLUE;

        String name = color.getName();

        System.out.println(name); // prints: BLUE
    }
}
</code></pre>
<p>A slightly similar (not a 1:1 mapping) version of the <code>RainbowColor</code> enum in Rust is shown below:</p>
<pre><code class="language-rust">#[derive(Debug)] // enables formatting in &quot;{:?}&quot;
enum RainbowColor {
    Red = 1,
    Orange = 2,
    Yellow = 3,
    Green = 4,
    Blue = 5,
    Indigo = 6,
    Violet = 7,
}

impl RainbowColor {
    fn new(number: i32) -&gt; Result&lt;RainbowColor, Box&lt;dyn std::error::Error&gt;&gt; {
        use RainbowColor::*;
        match number {
            1 =&gt; Ok(Red),
            2 =&gt; Ok(Orange),
            3 =&gt; Ok(Yellow),
            4 =&gt; Ok(Green),
            5 =&gt; Ok(Blue),
            6 =&gt; Ok(Indigo),
            7 =&gt; Ok(Violet),
            _ =&gt; return Err(format!(&quot;Illegal: {}&quot;, number).into())
        }
    }
}</code></pre>
<p>The <code>new()</code> function returns a <code>RainbowColor</code> in a <code>Result</code> indicating success
(<code>Ok</code>) if <code>number</code> is valid. Otherwise it panics:</p>
<pre><code class="language-rust">let color = RainbowColor::new(5);
println!(&quot;{color:?}&quot;); // prints: Ok(Blue)

let color = RainbowColor::new(10);
println!(&quot;{color:?}&quot;); // prints: Err(&quot;Illegal: 10&quot;)</code></pre>
<p>An <code>enum</code> type in Rust can also serve as a way to design (discriminated) union
types, which allow different <em>variants</em> to hold data specific to each variant.
For example:</p>
<pre><code class="language-rust">enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));</code></pre>
<p>Enums in Rust are most similar to <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data types</em></a> in functional languages, such as OCaml and Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="members"><a class="header" href="#members">Members</a></h1>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>Rust does not have any notion of constructors. Instead, you just write factory
functions that return an instance of the type. The factory functions can be
stand-alone or <em>associated functions</em> of the type. In Java terms, associated
functions are like having static methods on a type. Conventionally, if there
is just one factory function for a <code>struct</code>, it's named <code>new</code>:</p>
<pre><code class="language-rust">struct Rectangle {
    length: f64,
    width: f64,
}

impl Rectangle {
    pub fn new(length: f64, width: f64) -&gt; Self {
        Self { length, width }
    }
}</code></pre>
<p>Since Rust functions (associated or otherwise) do not support overloading; the
factory functions have to be named uniquely. For example, below are some
examples of so-called constructors or factory functions available on <code>String</code>:</p>
<ul>
<li><code>String::new</code>: creates an empty string.</li>
<li><code>String::with_capacity</code>: creates a string with an initial buffer capacity.</li>
<li><code>String::from_utf8</code>: creates a string from bytes of UTF-8 encoded text.</li>
<li><code>String::from_utf16</code>: creates a string from bytes of UTF-16 encoded text.</li>
</ul>
<p>In the case of an <code>enum</code> type in Rust, the variants act as the constructors.
See <a href="language/custom-types/enums.html">the section on enumeration types</a> for more.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://rust-lang.github.io/api-guidelines/predictability.html?highlight=new#constructors-are-static-inherent-methods-c-ctor">Constructors are static, inherent methods (C-CTOR)</a></p>
</li>
</ul>
<h2 id="methods-static--instance-based"><a class="header" href="#methods-static--instance-based">Methods (static &amp; instance-based)</a></h2>
<p>Like Java, Rust types (both <code>enum</code> and <code>struct</code>), can have static and
instance-based methods. In Rust-speak, a <em>method</em> is always instance-based and
is identified by the fact that its first parameter is named <code>self</code>. The <code>self</code>
parameter has no type annotation since it's always the type to which the
method belongs. A static method is called an <em>associated function</em>. In the
example below, <code>new</code> is an associated function and the rest (<code>length</code>, <code>width</code>
and <code>area</code>) are methods of the type:</p>
<pre><code class="language-rust">struct Rectangle {
    length: f64,
    width: f64,
}

impl Rectangle {
    pub fn new(length: f64, width: f64) -&gt; Self {
        Self { length, width }
    }

    pub fn length(&amp;self) -&gt; f64 {
        self.length
    }

    pub fn width(&amp;self)  -&gt; f64 {
        self.width
    }

    pub fn area(&amp;self)  -&gt; f64 {
        self.length() * self.width()
    }
}</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>In Java, it is generally good practice for fields of a type (e.g. a class) to be private. They are then
protected/encapsulated by property members with accessor methods (<code>getters</code> and
<code>setters</code>) to read or write to those fields. The accessor methods can contain extra
logic, for example, to either validate the value when being set or compute a
value when being read. Rust only has methods <a href="https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md#gettersetter-apis">where a getter is named after the
field (in Rust method names can share the same identifier as a field) and the
setter uses a <code>set_</code> prefix</a>.</p>
<p>Below is an example showing how property-like accessor methods typically look
for a type in Rust:</p>
<pre><code class="language-rust">struct Rectangle {
    length: f64,
    width: f64,
}

impl Rectangle {
    pub fn new(length: f64, width: f64) -&gt; Self {
        Self { length, width }
    }

    // like property getters (each shares the same name as the field)

    pub fn length(&amp;self) -&gt; f64 { self.length }
    pub fn width(&amp;self)  -&gt; f64 { self.width }

    // like property setters

    pub fn set_length(&amp;mut self, val: f64) { self.length = val }
    pub fn set_width(&amp;mut self, val: f64) { self.width = val }

    // like computed properties

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}</code></pre>
<h2 id="visibilityaccess-modifiers"><a class="header" href="#visibilityaccess-modifiers">Visibility/Access modifiers</a></h2>
<p>Java has a number of accessibility or visibility modifiers:</p>
<ul>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>package private</code></li>
<li><code>public</code></li>
</ul>
<p>In Rust, a compilation is built-up of a tree of modules where modules contain
and define <a href="https://doc.rust-lang.org/reference/items.html"><em>items</em></a> like types, traits, enums, constants and
functions. Almost everything is private by default. One exception is, for
example, <em>associated items</em> in a public trait, which are public by default.
This is similar to how members of a Java interface declared without any public
modifiers in the source code are public by default. Rust only has the <code>pub</code>
modifier to change the visibility with respect to the module tree. There
are variations of <code>pub</code> that change the scope of the public visibility:</p>
<ul>
<li><code>pub(self)</code></li>
<li><code>pub(super)</code></li>
<li><code>pub(crate)</code></li>
<li><code>pub(in PATH)</code></li>
</ul>
<p>For more details, see the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility and Privacy</a> section of The Rust
Reference.</p>
<p>The table below is an approximation of the mapping of Java and Rust modifiers:</p>
<div class="table-wrapper"><table><thead><tr><th>Java</th><th>Rust</th><th>Note</th></tr></thead><tbody>
<tr><td><code>private</code></td><td>(default)</td><td>See note 1.</td></tr>
<tr><td><code>protected</code></td><td>N/A</td><td>See note 2.</td></tr>
<tr><td><code>package private</code></td><td><code>pub(crate)</code></td><td></td></tr>
<tr><td><code>public</code></td><td><code>pub</code></td><td></td></tr>
</tbody></table>
</div>
<ol>
<li>
<p>There is no keyword to denote private visibility; it's the default in Rust.</p>
</li>
<li>
<p>Since there are no class-based type hierarchies in Rust, there is no
equivalent of <code>protected</code>.</p>
</li>
</ol>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>When designing a type in Java, it is the responsiblity of the developer to
decide whether the type is mutable or immutable. Java does support an immutable design
for &quot;<em>data carriers</em>&quot; with <code>record classes</code>.</p>
<p>In Rust, mutability is expressed on methods through the type
of the <code>self</code> parameter as shown in the example below:</p>
<pre><code class="language-rust">struct Point {
    x: f64,
    y: f64,
}

impl Point {
    pub fn new(x: f64, y: f64) -&gt; Self {
        Self { x, y }
    }

    // self is not mutable

    pub fn x(&amp;self) -&gt; f64 { self.x }
    pub fn y(&amp;self) -&gt; f64 { self.y }

    // self is mutable

    pub fn set_x(&amp;mut self, val: f64) { self.x = val }
    pub fn set_y(&amp;mut self, val: f64) { self.y = val }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas-and-closures"><a class="header" href="#lambdas-and-closures">Lambdas and Closures</a></h1>
<p>Java has a feature for defining anonymous functions in the form of 
<em>lambda expressions</em><sup class="footnote-reference"><a href="#lambda">1</a></sup>. The syntax for a lambda expression in Java looks as follows:</p>
<pre><code> ( paramlist ) -&gt; { /* method body */ }
</code></pre>
<p>In Rust, anonymous functions are called <em>closures</em>. The syntax for a closure expression in Rust looks as follows:</p>
<pre><code> | paramlist | { /* function body */ }
</code></pre>
<blockquote>
<p>Note: In both Java and Rust, the types of the parameters will typically be inferred.</p>
</blockquote>
<p>In addition to closures, Rust has <em>function pointers</em> that implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code>). Rust makes a distinction between function pointers (where <code>fn</code>
defines a type) and closures: a closure can reference variables from its surrounding lexical scope, but not a function pointer.</p>
<p>While Java doesn't have function pointers, it provides a set of functional interfaces (in the <code>java.util.function</code> package) that can be used as target types for lambda expressions (and method references). You can also define your own functional interfaces as well (as we do in the Java code example below).</p>
<p>In Rust, functions and methods that accept closures are written with generic types that
are bound to one of the closure traits: <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code>. When it's time to provide a value for a function pointer or a closure, you would use a <em>closure expression</em> (like <code>|x| x + 1</code>), which translates to something similar to a lambda expression in Java. Whether the closure expression creates a function pointer or a closure depends on whether the closure expression references its context or not.</p>
<p>When a closure captures variables from its environment then ownership rules come into play because the ownership ends up with the closure. For more information, see the “<a href="https://doc.rust-lang.org/book/ch13-01-closures.html#moving-captured-values-out-of-closures-and-the-fn-traits">Moving Captured Values Out of Closures and the Fn Traits</a>” section of the Rust book.</p>
<p>Let's look at a Rust example that showcases all these functionalities:</p>
<pre><code class="language-rust">struct Customer {
    name: String,
    gross_income: f64,
}

impl Customer {
    pub fn new(name: String, gross_income: f64) -&gt; Self {
        Self { name, gross_income }
    }
    
    pub fn name(&amp;self) -&gt; String {
        self.name.clone()
    }
    
    pub fn gross_income(&amp;self)  -&gt; f64 {
        self.gross_income
    }
}

// Note: the parameter func is of type fn, which is a function pointer
fn apply_tax_calc_function(func: fn(f64) -&gt; f64, arg: f64) -&gt; f64 {
    func(arg)
}

fn main() {
    let customer = Customer::new(&quot;Jane Doe&quot;.to_string(), 50000 as f64);

    let name = customer.name();
    let income = customer.gross_income();

    let tax_function_closure = |income| {
        let payable_tax: f64;
        if income &lt; 30000 as f64 {
            payable_tax = income * 0.05;
        } else {
            payable_tax = income * 0.06;
        }
        payable_tax
    };

    let calculated_tax = apply_tax_calc_function(tax_function_closure, income); // we pass in a closure

    println!(&quot;The calculated tax for {} is {}&quot;, name, calculated_tax); // prints: The calculated tax for Jane Doe is 3000
}</code></pre>
<p>Here's how we can achieve the equivalent functionality in Java:</p>
<pre><code class="language-java">// we define our own functional interface
@FunctionalInterface
interface TaxFunction {
    double calculateTax(double grossIncome);
}

record Customer(String name, double grossIncome) {

    public double applyTaxCalcFunction(TaxFunction taxFunc) {
        double calculatedTax = taxFunc.calculateTax(grossIncome);
        return calculatedTax;
    }
}

public class TestClass {

    public static void main(String[] args) {

          // define a function as a lambda expression and assign the result to a variable
          TaxFunction taxFunction = (grossIncome) -&gt; {
              double payableTax;

              if (grossIncome &lt; 30000) {
                  payableTax = grossIncome * 0.05;
              } else {
                  payableTax = grossIncome * 0.06;
              }

              return payableTax;
          };

          Customer customer = new Customer(&quot;Jane Doe&quot;, 50000);

          String name = customer.name();

          double calculatedTax = customer.applyTaxCalcFunction(taxFunction); // we pass in a lambda expression

          System.out.println(&quot;The calculated tax for &quot; + name + &quot; is &quot;+ calculatedTax); // prints: The calculated tax for Jane Doe is 3000.0
    }
}
</code></pre>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-order functions</a></h2>
<p>Higher-order functions are functions that accept other functions as arguments to allow for the caller to participate in the code of the called function. As we've already seen in the code examples above, in both Rust and Java, we can pass closures and lambda expressions to functions. But unlike in Java, Rust also allows <em>regular functions</em> to be passed into other functions:</p>
<pre><code class="language-rust">struct Customer {
    name: String,
    gross_income: f64,
}

impl Customer {
    pub fn new(name: String, gross_income: f64) -&gt; Self {
        Self { name, gross_income }
    }
    
    pub fn name(&amp;self) -&gt; String {
        self.name.clone()
    }
    
    pub fn gross_income(&amp;self)  -&gt; f64 {
        self.gross_income
    }
}

// Note: the parameter func is of type fn, which is a function pointer
fn apply_tax_calc_function(func: fn(f64) -&gt; f64, arg: f64) -&gt; f64 {
    func(arg)
}

// define a regular function
fn tax_function_regular(income: f64) -&gt; f64 {
    let payable_tax: f64;
    if income &lt; 30000 as f64 {
        payable_tax = income * 0.05;
    } else {
        payable_tax = income * 0.06;
    }
    payable_tax
}

fn main() {
    let customer = Customer::new(&quot;Jane Doe&quot;.to_string(), 50000 as f64);

    let name = customer.name();
    let income = customer.gross_income();

    let calculated_tax = apply_tax_calc_function(tax_function_regular, income); // we pass in a regular function

    println!(&quot;The calculated tax for {} is {}&quot;, name, calculated_tax); // prints: The calculated tax for Jane Doe is 3000
}</code></pre>
<hr />
<div class="footnote-definition" id="lambda"><sup class="footnote-definition-label">1</sup>
<p>Lambda expressions were introduced in Java 8.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="streams-and-iterators"><a class="header" href="#streams-and-iterators">Streams and Iterators</a></h1>
<p>This section discusses Java's <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html">Stream API</a> within the context and for the purpose of transforming sequences (<code>Iterator&lt;E&gt;</code>/<code>Iterable&lt;T&gt;</code>) and typically collections like lists, sets and maps.</p>
<h2 id="iterablet-interface"><a class="header" href="#iterablet-interface"><code>Iterable&lt;T&gt; Interface</code></a></h2>
<p>The equivalent of Java's <code>Iterable&lt;T&gt;</code> in Rust is <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>.
Just as an implementation of <code>Iterable&lt;T&gt;.iterator()</code> returns a
<code>Iterator&lt;T&gt;</code> in Java, an implementation of <code>IntoIterator::into_iter</code>
returns an <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>. However, when it's time to iterate over the
items of a container advertising iteration support through the said types,
both languages offer syntactic sugar in the form of looping constructs for
iteratables. In Java, there is the enhanced <code>for</code> statement (also known as the <code>for-each</code> loop).</p>
<pre><code class="language-java">int[] values = { 1, 2, 3, 4, 5 };

StringBuilder output = new StringBuilder();

for (var value : values) {
    if (output.length() &gt; 0) {
        output.append(&quot;, &quot;);
    }
    output.append(value);
}

System.out.println(output); // prints: 1, 2, 3, 4, 5
</code></pre>
<p>In Rust, the equivalent is simply <code>for</code>:</p>
<pre><code class="language-rust">use std::fmt::Write;

fn main() {
    let values = [1, 2, 3, 4, 5];
    let mut output = String::new();

    for value in values {
        if output.len() &gt; 0 {
            output.push_str(&quot;, &quot;);
        }
        // ! discard/ignore any write error
        _ = write!(output, &quot;{value}&quot;);
    }

    println!(&quot;{output}&quot;);  // Prints: 1, 2, 3, 4, 5
}</code></pre>
<p>The <code>for</code> loop over an iterable essentially gets desugared to the following:</p>
<pre><code class="language-rust">use std::fmt::Write;

fn main() {
    let values = [1, 2, 3, 4, 5];
    let mut output = String::new();

    let mut iter = values.into_iter();      // get iterator
    while let Some(value) = iter.next() {   // loop as long as there are more items
        if output.len() &gt; 0 {
            output.push_str(&quot;, &quot;);
        }
        _ = write!(output, &quot;{value}&quot;);
    }

    println!(&quot;{output}&quot;);
}</code></pre>
<p>Here's a Java example that uses the <code>forEach()</code> method:</p>
<pre><code class="language-java">Map&lt;String, String&gt; houses = new HashMap&lt;&gt;(Map.of(
                &quot;Stark&quot;, &quot;Winter Is Coming&quot;,
                &quot;Targaryen&quot;, &quot;Fire and Blood&quot;,
                &quot;Lannister&quot;, &quot;Hear Me Roar&quot;,
                &quot;Arryn&quot;, &quot;As High as Honor&quot;,
                &quot;Tully&quot;, &quot;Family, Duty, Honor&quot;,
                &quot;Greyjoy&quot;, &quot;We Do Not Sow&quot;,
                &quot;Baratheon&quot;, &quot;Ours is the Fury&quot;,
                &quot;Tyrell&quot;, &quot;Growing Strong&quot;,
                &quot;Martell&quot;, &quot;Unbowed, Unbent, Unbroken&quot;,
                &quot;Hightower&quot;, &quot;We Light the Way&quot;
                ));

houses.entrySet()
        .stream()
        .forEach(house -&gt; System.out.println(
                          &quot;House: &quot; + house.getKey() 
                                    + &quot;,&quot; + &quot; Motto: &quot;
                                    + house.getValue()));

</code></pre>
<p>The output looks as follows:</p>
<pre><code>House: Lannister, Motto: Hear Me Roar
House: Targaryen, Motto: Fire and Blood
House: Baratheon, Motto: Ours is the Fury
House: Hightower, Motto: We Light the Way
House: Martell, Motto: Unbowed, Unbent, Unbroken
House: Tyrell, Motto: Growing Strong
House: Tully, Motto: Family, Duty, Honor
House: Stark, Motto: Winter Is Coming
House: Arryn, Motto: As High as Honor
House: Greyjoy, Motto: We Do Not Sow
</code></pre>
<p>Here's the Rust equivalent:</p>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {

    let houses = HashMap::from([
            (&quot;Stark&quot;.to_owned(), &quot;Winter Is Coming&quot;.to_owned()),
            (&quot;Targaryen&quot;.to_owned(), &quot;Fire and Blood&quot;.to_owned()),
            (&quot;Lannister&quot;.to_owned(), &quot;Hear Me Roar&quot;.to_owned()),
            (&quot;Arryn&quot;.to_owned(), &quot;As High as Honor&quot;.to_owned()),
            (&quot;Tully&quot;.to_owned(), &quot;Family, Duty, Honor&quot;.to_owned()),
            (&quot;Greyjoy&quot;.to_owned(), &quot;We Do Not Sow&quot;.to_owned()),
            (&quot;Baratheon&quot;.to_owned(), &quot;Ours is the Fury&quot;.to_owned()),
            (&quot;Tyrell&quot;.to_owned(), &quot;Growing Strong&quot;.to_owned()),
            (&quot;Martell&quot;.to_owned(), &quot;Unbowed, Unbent, Unbroken&quot;.to_owned()),
            (&quot;Hightower&quot;.to_owned(), &quot;We Light the Way&quot;.to_owned())
    ]);


    for (key, value) in houses.iter() {
        println!(&quot;House: {}, Motto: {}&quot;, key, value);
    }
}</code></pre>
<p>The output for the Rust version looks as follows:</p>
<pre><code>House: Baratheon, Motto: Ours is the Fury
House: Stark, Motto: Winter Is Coming
House: Targaryen, Motto: Fire and Blood
House: Martell, Motto: Unbowed, Unbent, Unbroken
House: Lannister, Motto: Hear Me Roar
House: Tyrell, Motto: Growing Strong
House: Arryn, Motto: As High as Honor
House: Tully, Motto: Family, Duty, Honor
House: Hightower, Motto: We Light the Way
House: Greyjoy, Motto: We Do Not Sow
</code></pre>
<p>Rust's ownership and data race condition rules apply to all instances and
data, and iteration is no exception. So while looping over an array might look
straightforward and very similar to Java, one has to be mindful about ownership
when needing to iterate the same collection/iterable more than once. The
following example iterates the list of integers twice, once to print their sum
and another time to determine and print the maximum integer:</p>
<pre><code class="language-rust">fn main() {
    let values = vec![1, 2, 3, 4, 5];

    // sum all values
    let mut sum = 0;
    for value in values {
        sum += value;
    }
    println!(&quot;sum = {sum}&quot;);

    // determine maximum value
    let mut max = None;
    for value in values {
        if let Some(some_max) = max { // if max is defined
            if value &gt; some_max {     // and value is greater
                max = Some(value)     // then note that new max
            }
        } else {                      // max is undefined when iteration starts
            max = Some(value)         // so set it to the first value
        }
    }
    println!(&quot;max = {max:?}&quot;);
}</code></pre>
<p>However, the code above is rejected by the compiler due to a subtle
difference: <code>values</code> has been changed from an array to a <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec&lt;int&gt;</code></a>,
a <em>vector</em>, which is Rust's type for growable arrays (like <code>List&lt;E&gt;</code> in Java).
The first iteration of <code>values</code> ends up <em>consuming</em> each value as the integers
are summed up. In other words, the ownership of <em>each item</em> in the vector
passes to the iteration variable of the loop: <code>value</code>. Since <code>value</code> goes out
of scope at the end of each iteration of the loop, the instance it owns is
dropped. Had <code>values</code> been a vector of heap-allocated data, the heap memory
backing each item would get freed as the loop moved to the next item. To fix
the problem, one has to request iteration over <em>shared</em> references via
<code>&amp;values</code> in the <code>for</code> loop. As a result, <code>value</code> ends up being a shared
reference to an item as opposed to taking its ownership.</p>
<p>Below is the updated version of the previous example that compiles. The fix is
to simply replace <code>values</code> with <code>&amp;values</code> in each of the <code>for</code> loops.</p>
<pre><code class="language-rust">fn main() {
    let values = vec![1, 2, 3, 4, 5];

    // sum all values
    let mut sum = 0;
    for value in &amp;values {
        sum += value;
    }
    println!(&quot;sum = {sum}&quot;);

    // determine maximum value
    let mut max = None;
    for value in &amp;values {
        if let Some(some_max) = max { // if max is defined
            if value &gt; some_max {     // and value is greater
                max = Some(value)     // then note that new max
            }
        } else {                      // max is undefined when iteration starts
            max = Some(value)         // so set it to the first value
        }
    }
    println!(&quot;max = {max:?}&quot;);
}</code></pre>
<p>The ownership and dropping can be seen in action even with <code>values</code> being an
array instead of a vector. Consider just the summing loop from the above
example over an array of a structure that wraps an integer:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Int(i32);

impl Drop for Int {
    fn drop(&amp;mut self) {
        println!(&quot;Int({}) dropped&quot;, self.0)
    }
}

fn main() {
    let values = [Int(1), Int(2), Int(3), Int(4), Int(5)];
    let mut sum = 0;

    for value in values {
        println!(&quot;value = {value:?}&quot;);
        sum += value.0;
    }

    println!(&quot;sum = {sum}&quot;);
}</code></pre>
<p><code>Int</code> implements <code>Drop</code> so that a message is printed when an instance get
dropped. Running the above code will print:</p>
<pre><code>value = Int(1)
Int(1) dropped
value = Int(2)
Int(2) dropped
value = Int(3)
Int(3) dropped
value = Int(4)
Int(4) dropped
value = Int(5)
Int(5) dropped
sum = 15
</code></pre>
<p>It's clear that each value is acquired and dropped while the loop is running.
Once the loop is complete, the sum is printed. If <code>values</code> in the <code>for</code> loop
is changed to <code>&amp;values</code> instead, like this:</p>
<pre><code class="language-rust">for value in &amp;values {
    // ...
}</code></pre>
<p>then the output of the program will change radically:</p>
<pre><code>value = Int(1)
value = Int(2)
value = Int(3)
value = Int(4)
value = Int(5)
sum = 15
Int(1) dropped
Int(2) dropped
Int(3) dropped
Int(4) dropped
Int(5) dropped
</code></pre>
<p>This time, values are acquired but not dropped while looping because each item
doesn't get owned by the interation loop's variable. The sum is printed ocne
the loop is done. Finally, when the <code>values</code> array that still owns all the the
<code>Int</code> instances goes out of scope at the end of <code>main</code>, its dropping in turn
drops all the <code>Int</code> instances.</p>
<p>These examples demonstrate that while iterating collection types may seem to
have a lot of parallels between Rust and Java, from the looping constructs to
the iteration abstractions, there are still subtle differences with respect to
ownership that can lead to the compiler rejecting the code in some instances.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/index.html">Iterator</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/index.html#iterating-by-reference">Iterating by reference</a></li>
</ul>
<h2 id="stream-operations"><a class="header" href="#stream-operations">Stream Operations</a></h2>
<p>Java's Stream API offers a set of <em>operations</em> (methods) that can be chained together to form stream <em>pipelines</em>. In Rust, such methods are called <em><a href="https://doc.rust-lang.org/std/iter/index.html#adapters">adapters</a></em>.</p>
<p>However, while rewriting an imperative loop as a stream in Java is often beneficial in expressivity, robustness and composability, there is a trade-off with performance. Compute-bound imperative loops <em>usually</em> run faster because they can be optimised by the JIT compiler and there are fewer virtual dispatches or indirect function invocations incurred. The surprising part in Rust is that there is no performance trade-off between choosing to use method chains on an abstraction like an iterator over writing an imperative loop by hand. It's therefore far more common to see the former in code.</p>
<p>The following table lists the most common Stream API methods and their approximate
counterparts in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Java</th><th>Rust</th><th>Note</th></tr></thead><tbody>
<tr><td><code>reduce</code></td><td><code>reduce</code></td><td>See note 1.</td></tr>
<tr><td><code>reduce</code></td><td><code>fold</code></td><td>See note 1.</td></tr>
<tr><td><code>allMatch</code></td><td><code>all</code></td><td></td></tr>
<tr><td><code>anyMatch</code></td><td><code>any</code></td><td></td></tr>
<tr><td><code>concat</code></td><td><code>chain</code></td><td></td></tr>
<tr><td><code>count</code></td><td><code>count</code></td><td></td></tr>
<tr><td><code>max</code></td><td><code>max</code></td><td></td></tr>
<tr><td><code>min</code></td><td><code>min</code></td><td></td></tr>
<tr><td><code>map</code></td><td><code>map</code></td><td></td></tr>
<tr><td><code>flatMap</code></td><td><code>flat_map</code></td><td></td></tr>
<tr><td><code>skip</code></td><td><code>skip</code></td><td></td></tr>
<tr><td><code>limit</code></td><td><code>take</code></td><td></td></tr>
<tr><td><code>takeWhile</code></td><td><code>take_while</code></td><td></td></tr>
<tr><td><code>collect</code></td><td><code>collect</code></td><td>See note 2.</td></tr>
<tr><td><code>filter</code></td><td><code>filter</code></td><td></td></tr>
</tbody></table>
</div>
<ol>
<li>
<p>Java's <code>reduce</code> method is overloaded. The one not accepting an identity value is 
equivalent to Rust's <code>reduce</code>, while the one accepting an identity value corresponds
to Rust's <code>fold</code>.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> in Rust generally works for any collectible type,
which is defined as <a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html">a type that can initialize itself from an iterator
(see <code>FromIterator</code>)</a>. <code>collect</code> needs a target type, which
the compiler sometimes has trouble inferring so the <em>turbofish</em> (<code>::&lt;&gt;</code>) is
often used in conjunction with it, as in <code>collect::&lt;Vec&lt;_&gt;&gt;()</code>.</p>
</li>
</ol>
<p>The following example shows how similar transforming sequences in Java is to
doing the same in Rust. First in Java:</p>
<pre><code class="language-java">int result = IntStream.range(0, 10)
                .filter(x -&gt; x % 2 == 0)
                .flatMap(x -&gt; IntStream.range(0, x))
                .reduce(0, Integer::sum);

System.out.println(result); // prints: 50
</code></pre>
<p>And in Rust:</p>
<pre><code class="language-rust">let result = (0..10)
    .filter(|x| x % 2 == 0)
    .flat_map(|x| (0..x))
    .fold(0, |acc, x| acc + x);

println!(&quot;{result}&quot;); // prints: 50</code></pre>
<h2 id="deferred-execution-laziness"><a class="header" href="#deferred-execution-laziness">Deferred execution (laziness)</a></h2>
<p>Java streams are lazy: computation on the source data is only performed when a 
<em>terminal operation</em> is initiated, and source elements are consumed only as needed. This enables composition or chaining of several (<em>intermediate</em>) operations/methods without causing any side-effects. For example, a stream operation can return an <code>Iterable&lt;T&gt;</code> that is initialized, but does not produce, compute or materialize any items of <code>T</code> until iterated. The operation is said to have <em>deferred execution</em> semantics (or <em>lazy evaluation</em>). If each <code>T</code> is computed as iteration reaches it (as opposed to when iteration begins) then the operation is said to <em>stream</em> the results.</p>
<p>Rust iterators have the same concept of <a href="https://doc.rust-lang.org/std/iter/index.html#laziness"><em>laziness</em></a> and
streaming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>Both Java and Rust provide facilities for pattern matching. We already saw some use of pattern matching in the <a href="language/./custom-types/enums.html">section for enums</a>.</p>
<p>Consider this Java method that makes use of an <code>if-then-else</code> statement:</p>
<pre><code class="language-java">String fooBar(Integer number) {
    if (number % 2 == 0) {
        return &quot;foo&quot;;
    } else if (number % 3 == 0) {
        return &quot;bar&quot;;
    } else {
        throw new RuntimeException(&quot;some other number: &quot; + number);
    }
}

System.out.println(fooBar(10)); // prints: foo
System.out.println(fooBar(15)); // prints: bar
System.out.println(fooBar(13)); // raises an exception and prints: some other number: 13
</code></pre>
<p>We can rewrite the code above to use pattern matching with <code>switch expression</code>:</p>
<pre><code class="language-java">String fooBar(Integer number) {
    return switch (number) {
        case Integer n when n % 2 == 0 -&gt; &quot;foo&quot;;
        case Integer n when n % 3 == 0 -&gt; &quot;bar&quot;;
        default -&gt; throw new RuntimeException(&quot;some other number: &quot; + number);
    };
}

System.out.println(fooBar(10)); // prints: foo
System.out.println(fooBar(15)); // prints: bar
System.out.println(fooBar(13)); // raises an exception and prints: some other number: 13
</code></pre>
<p>Here's the Rust equivalent:</p>
<pre><code class="language-rust">fn foo_bar(number: i32) -&gt; String {
    match number {
        n if n % 2 == 0 =&gt; &quot;foo&quot;.to_string(),
        n if n % 3 == 0 =&gt; &quot;bar&quot;.to_string(),
                      _ =&gt; panic!(&quot;some other number: {}&quot;, number)
    }
}

fn main() {
    println!(&quot;{}&quot;, foo_bar(10)); // prints foo
    println!(&quot;{}&quot;, foo_bar(15)); // prints: bar
    println!(&quot;{}&quot;, foo_bar(13)); // panics and prints: some other number: 13
}</code></pre>
<p>The <code>if</code> condition in each of the match arms is called a <em>match guard</em> in Rust.</p>
<p>Let's consider the following Java interface:</p>
<pre><code class="language-java">public interface Shape {

    public double area();
}
</code></pre>
<p>And the following types that implement the <code>Shape</code> interface (overriding the <code>area</code> method):</p>
<pre><code class="language-java">record Circle(double radius) implements Shape {

    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}

record Rectangle(double length, double width) implements Shape {

    @Override
    public double area() {
        return length * width;
    }
}

record Triangle(double base, double height) implements Shape {

    @Override
    public double area() {
        return 0.5 * base * height;
    }
}
</code></pre>
<p>Now, here's how we can use pattern matching with switch expression to get the area of each type of shape:</p>
<pre><code class="language-java">public static double getAreaOfShape(Shape shape) throws IllegalArgumentException {
    return switch (shape) {
    	case Circle c    -&gt; c.area();
        case Rectangle r -&gt; r.area();
        case Triangle t  -&gt; t.area();
        default          -&gt; throw new IllegalArgumentException(&quot;Unrecognized shape&quot;);
    };
}
</code></pre>
<p>And this is how we can exercise the method:</p>
<pre><code class="language-java">Circle shape1 = new Circle(2.0);
double areaOfCircle = getAreaOfShape(shape1);
System.out.println(&quot;Area of Circle is: &quot; + areaOfCircle); // prints: Area of Circle is: 12.566370614359172

Rectangle shape2 = new Rectangle(4.0, 2.0);
double areaOfRectangle = getAreaOfShape(shape2);
System.out.println(&quot;Area of Rectangle is: &quot; + areaOfRectangle); // prints: Area of Rectangle is: 8.0

Triangle shape3 = new Triangle(4.0, 3.0);
double areaOfTriangle = getAreaOfShape(shape3);
System.out.println(&quot;Area of Triangle is: &quot; + areaOfTriangle); // prints: Area of Triangle is: 6.0
</code></pre>
<p>Before the addition of pattern matching functionality in Java, this is how we would implement the <code>getAreaOfShape</code> method:</p>
<pre><code class="language-java">public static double getAreaOfShape(Shape shape) throws IllegalArgumentException {
    if (shape instanceof Rectangle r) {
        return r.area();
    } else if (shape instanceof Circle c) {
        return c.area();
    } else if (shape instanceof Triangle t) {
        return t.area();
    } else {
        throw new IllegalArgumentException(&quot;Unrecognized shape&quot;);
    }
}
</code></pre>
<p>Here's the Rust equivalent code:</p>
<pre><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    length: f64,
    width: f64,
}

struct Triangle {
    base: f64,
    height: f64,
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

impl Shape for Rectangle {
    fn area(&amp;self) -&gt; f64 {
        self.length * self.width
    }
}

impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

enum ShapeType {
    Circle(Circle),
    Rectangle(Rectangle),
    Triangle(Triangle),
}</code></pre>
<p>We can then get the area using pattern matching as shown below:</p>
<pre><code class="language-rust">fn get_area_of_shape(shape: ShapeType) -&gt; f64 {
    
    match shape {
        ShapeType::Circle(circle) =&gt; circle.area(),
        ShapeType::Rectangle(rectangle) =&gt; rectangle.area(),
        ShapeType::Triangle(triangle) =&gt; triangle.area(),
    }
}</code></pre>
<p>And here's how we can use the function:</p>
<pre><code class="language-rust">fn main() {
    let shape1 = ShapeType::Circle(Circle { radius: 2.0 });
    let area_of_circle = get_area_of_shape(shape1);
    println!(&quot;The area of circle is {}&quot;, area_of_circle); // prints: The area of circle is 12.566370614359172
    
    let shape2 = ShapeType::Rectangle(Rectangle { length: 4.0, width: 2.0 });
    let area_of_rectangle = get_area_of_shape(shape2);
    println!(&quot;The area of rectangle is {}&quot;, area_of_rectangle); // prints: The area of rectangle is 8
    
    let shape3 = ShapeType::Triangle(Triangle { base: 4.0, height: 3.0 });
    let area_of_triangle = get_area_of_shape(shape3);
    println!(&quot;The area of triangle is {}&quot;, area_of_triangle); // prints: The area of triangle is 6
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-and-modules"><a class="header" href="#packages-and-modules">Packages and Modules</a></h1>
<p>Packages are used in Java to organize types, as well as for controlling the
scope of types and methods in projects.</p>
<p>The equivalent of a package in Rust is a <a href="https://doc.rust-lang.org/reference/items/modules.html">module</a>. For both Java and Rust, visibility of items can be restricted using access modifiers and visibility modifiers respectively. In Rust, the default visibility is <em>private</em> (with only few exceptions). The equivalent of Java's <code>public</code> is <code>pub</code> in Rust, and <code>package-private</code> corresponds to 
<code>pub(crate)</code>. For more fine-grained access control, refer to the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility modifiers</a> reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality"><a class="header" href="#equality">Equality</a></h1>
<p>When comparing for equality in Java, this may refer to testing for <em>object equality</em> in
some cases, and in other cases it may refer to testing for <em>reference equality</em>, which tests whether two variables refer/point to the same underlying object in memory. Every custom type can be compared for equality because it inherits from the <code>Object</code> root class (which provides an <code>equals()</code> method).</p>
<p>For example, when comparing for object and reference equality in Java:</p>
<pre><code class="language-java">record Point(int x, int y) {}

var a = new Point(1, 2);
var b = new Point(1, 2);
var c = new Point(2, 2);
var d = a;

System.out.println(a == b); // (1) false
System.out.println(a.equals(b)); // (2) true
System.out.println(a.equals(c)); // (2) false
System.out.println(a == d); // (1) true
System.out.println(a.equals(d)); // true
</code></pre>
<ol>
<li>
<p>The equality operator <code>==</code> is used to compare for reference equality. In this case,
variables <code>a</code> and <code>b</code> are referring/pointing to different objects in memory.</p>
</li>
<li>
<p>The <code>equals()</code> method is used to compare for object equality, i.e. whether two 
distinct objects have the same content.</p>
</li>
</ol>
<p>Equivalently in Rust:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
struct Point(i32, i32);

fn main() {
    let a = Point(1, 2);
    let b = Point(1, 2);
    let c = Point(2, 2);
    let d = a;
    println!(&quot;{}&quot;, a == b); // Error: &quot;an implementation of `PartialEq&lt;_&gt;` might be missing for `Point`&quot;
    println!(&quot;{}&quot;, a.eq(&amp;b));
    println!(&quot;{}&quot;, a.eq(&amp;c));
}</code></pre>
<p>The compiler error above illustrates that in Rust equality comparisons are
<em>always</em> related to a trait implementation. To support a comparison using <code>==</code>,
a type must implement <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>.</p>
<p>Fixing the example above means deriving <code>PartialEq</code> for <code>Point</code>. Per default,
deriving <code>PartialEq</code> will compare all fields for equality, which therefore have
to implement <code>PartialEq</code> themselves.</p>
<pre><code class="language-rust">#[derive(Copy, Clone, PartialEq)]
struct Point(i32, i32);

fn main() {
    let a = Point(1, 2);
    let b = Point(1, 2);
    let c = Point(2, 2);
    let d = a;

    println!(&quot;{}&quot;, a == b);   // true
    println!(&quot;{}&quot;, a.eq(&amp;b)); // true
    println!(&quot;{}&quot;, a.eq(&amp;c)); // false
    println!(&quot;{}&quot;, a.eq(&amp;d)); // true
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a> for a stricter version of <code>PartialEq</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics in Java provide a way to create definitions for types and methods that
can be parameterized over other types. This improves code reuse, type-safety
and performance (e.g. avoid run-time casts).</p>
<p>Consider the following example of a generic <code>Point</code> type in Java:</p>
<pre><code class="language-java">public record Point&lt;T&gt;(T x, T y) {}

// creating instances of Point
Point&lt;Integer&gt; p1 = new Point&lt;&gt;(10, 12);
Point&lt;Double&gt; p2 = new Point&lt;&gt;(10.5, 12.4);

</code></pre>
<p>Here's the Rust equivalent:</p>
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {

    // creating instances of Point struct
    let p1 = Point { x: 10, y: 12, };
    let p2 = Point { x: 10.5, y: 12.4, };
}</code></pre>
<p>Here's another example of a generic type in Java:</p>
<pre><code class="language-java">record Rectangle&lt;T&gt;(T length, T width) {

    // Accessor method. Not necessary, added for illustration purposes
    public T length() {
        return length;
    }

    // Accessor method. Not necessary, added for illustration purposes
    public T width() {
        return width;
    }
}

Rectangle2&lt;Integer&gt; rect1 = new Rectangle2&lt;&gt;(10, 5);
Rectangle2&lt;Double&gt; rect2 = new Rectangle2&lt;&gt;(12.4, 6.2);

System.out.println(&quot;Length of rect1 is: &quot; + rect1.length()); // prints: Length of rect1 is: 10
System.out.println(&quot;Length of rect2 is: &quot; + rect2.length());// prints: Length of rect2 is: 12.4
</code></pre>
<p>Rust also has generics as shown by the equivalent of the above:</p>
<pre><code class="language-rust">#![allow(dead_code)]


struct Rectangle&lt;T&gt; {
    length: T,
    width: T,
}

impl&lt;T&gt; Rectangle&lt;T&gt; {

    pub fn length(&amp;self) -&gt; &amp;T {
        &amp;self.length
    }

    pub fn width(&amp;self)  -&gt; &amp;T {
        &amp;self.width
    }
}


fn main() {
    let rect1 = Rectangle { length: 10, width: 5 };
    let rect2 = Rectangle { length: 12.4, width: 6.2 };

    println!(&quot;Length of rect1 is: {}&quot;, rect1.length()); // prints: Length of rect1 is: 10
    println!(&quot;Length of rect2 is: {}&quot;, rect2.length()); // prints: Length of rect2 is: 12.4
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">Generic data types</a></li>
</ul>
<h2 id="bounded-type-parameters"><a class="header" href="#bounded-type-parameters">Bounded type parameters</a></h2>
<p>In Java, bounded type parameters are used to specify generic types with restrictions related to inheritance hierarchies.</p>
<p>Consider the following example of a generic type that adds a timestamp to any value:</p>
<pre><code class="language-java">import java.time.Instant;

record Timestamped&lt;T extends Comparable&lt;T&gt;&gt;(T value, Instant timestamp) 
    implements Comparable&lt;Timestamped&lt;T&gt;&gt; {

    public Timestamped(T value) {
        this(value, Instant.now());
    }

    @Override
    public int compareTo(Timestamped&lt;T&gt; o) {
        Timestamped&lt;? extends Comparable&lt;T&gt;&gt; that = o;
        return value.compareTo((T) that.value);
    }
}

Timestamped&lt;String&gt; timestamped1 = new Timestamped&lt;&gt;(&quot;Hello&quot;);
Timestamped&lt;String&gt; timestamped2 = new Timestamped&lt;&gt;(&quot;Hello&quot;, Instant.now());
Timestamped&lt;String&gt; timestamped3 = new Timestamped&lt;&gt;(&quot;Haha&quot;, Instant.now());
Timestamped&lt;String&gt; timestamped4 = new Timestamped&lt;&gt;( &quot;House&quot;, Instant.now());

System.out.println(timestamped1.compareTo(timestamped2)); // prints: 0
System.out.println(timestamped1.compareTo(timestamped3)); // prints: 4 (+ve integer)
System.out.println(timestamped1.compareTo(timestamped4)); // prints: -10 (-ve integer)
</code></pre>
<p>The same result can be achieved in Rust as shown below:</p>
<pre><code class="language-rust">#![allow(dead_code)]

use std::time::Instant;
use std::cmp::Ordering;

#[derive(Debug)]
struct Timestamped&lt;T: Ord&gt; { 
    value: T, 
    timestamp: Instant 
}

impl&lt;T: Ord&gt; Timestamped&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, timestamp: Instant::now() }
    }
}

impl&lt;T: Ord&gt; Ord for Timestamped&lt;T&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.value.cmp(&amp;other.value)
    }
}

impl&lt;T&gt; PartialOrd for Timestamped&lt;T&gt;
    where T: PartialEq + Ord {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl&lt;T&gt; PartialEq for Timestamped&lt;T&gt;
    where T: PartialEq + Ord {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.value == other.value
    }
}

impl&lt;T&gt; Eq for Timestamped&lt;T&gt; where T: PartialEq + Ord {}

fn main() {
    
    let timestamped1 = Timestamped::new(&quot;Hello&quot;);
    let timestamped2 = Timestamped { value: &quot;Hello&quot;, timestamp: Instant::now() };
    let timestamped3 = Timestamped { value: &quot;Haha&quot;, timestamp: Instant::now() };
    let timestamped4 = Timestamped { value: &quot;House&quot;, timestamp: Instant::now() };
    
    println!(&quot;{:?}&quot;, timestamped1.cmp(&amp;timestamped2)); // prints: Equal
    println!(&quot;{:?}&quot;, timestamped1.cmp(&amp;timestamped3)); // prints: Greater
    println!(&quot;{:?}&quot;, timestamped1.cmp(&amp;timestamped4)); // prints: Less
}</code></pre>
<p>Generic type constraints in Rust (also called <a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">trait bounds</a>), can be declared using the colon syntax (e.g. <code>T: Ord</code>) or the <code>where</code> clause (e.g. <code>where T: PartialEq + Ord</code>).</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters">Traits as parameters</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits">Returning types that implement traits</a></li>
</ul>
<h2 id="type-erasure-and-monomorphization"><a class="header" href="#type-erasure-and-monomorphization">Type erasure and monomorphization</a></h2>
<p>During compilation, the Java compiler erases the parameterized data type in the byte code (replacing the parameterized type with its concrete equivalent). After compilation, the JVM does not see any distinction between the <code>parameterized</code> and the <code>raw</code> data types. This phenomenon is called <code>type erasure</code>.</p>
<p>The Rust compiler on the other hand performs <code>monomorphization</code> of the code that uses generics. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used after compilation. This ensures that the resulting code is as performant as code written without using generic types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>Rust does not support classes and sub-classing; therefore polymorphism can't be
achieved in an identical manner to Java.</p>
<p>In Rust, polymorphism is mainly achieved via <em>virtual dispatch</em> using <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a>.</p>
<p>See also:</p>
<ul>
<li><a href="language/./generics.html">Generics</a></li>
<li><a href="language/./inheritance.html">Inheritance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h1>
<p>Rust does not provide (class-based) inheritance or type hierarchies as in Java. A way to provide shared behavior between structs is via making use of <em>traits</em>. However, similar to <em>interface inheritance</em> in Java, Rust allows defining relationships between traits by using <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait"><em>supertraits</em></a>.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch17-00-oop.html">Object Oriented Programming Features of Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>In Java, an <em>exception</em> is a type that inherits from the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Throwable.html"><code>Throwable</code></a> class. This class is the superclass of all errors and exceptions in the Java language. Exceptions are thrown if a problem occurs in a code section. A thrown exception is passed up the stack until the application handles it or the program terminates.</p>
<p>Java distinguishes between <em>checked</em> and <em>unchecked</em> exceptions. The <code>Throwable</code> class has two immmediate descendant classes: <code>Error</code> and <code>Exception</code>. Subclasses of the <code>Error</code> class are fatal errors and are called <em>unchecked</em> exceptions, and are not required to be caught. Subclasses of the <code>Exception</code> class (excluding <code>RuntimeException</code>) are called 
<em>checked</em> exceptions and have to be handled in your code.</p>
<p>Rust does not have exceptions, but distinguishes between <em>recoverable</em> and 
<em>unrecoverable</em> errors instead. A recoverable error represents a problem that
should be reported, but for which the program continues. Results of operations
that can fail with recoverable errors are of type <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>,
where <code>E</code> is the type of the error variant. The <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> macro stops
execution when the program encounters an unrecoverable error. An unrecoverable
error is always a symptom of a bug.</p>
<h2 id="custom-error-types"><a class="header" href="#custom-error-types">Custom error types</a></h2>
<p>In Java, you can create your own custom exceptions by extending the <code>Exception</code> class (or one of the classes from the <code>Throwable</code> hierarchy). Here's a simple example:</p>
<pre><code class="language-java">public class EmployeeListNotFoundException extends Exception {

    public EmployeeListNotFoundException() { }

    public EmployeeListNotFoundException(String message) {
        super(message);
    }

    public EmployeeListNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
</code></pre>
<p>In Rust, one can implement the basic expectations for error values by
implementing the <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait. The minimal user-defined error
implementation in Rust is:</p>
<pre><code class="language-rust">#[derive(Debug)]
pub struct EmployeeListNotFound;

impl std::fmt::Display for EmployeeListNotFound {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_str(&quot;Could not find employee list.&quot;)
    }
}

impl std::error::Error for EmployeeListNotFound {}</code></pre>
<p>The equivalent to Java's <code>Throwable.getCause()</code> method is the <code>Error::source()</code> method in Rust. However, it is not required to provide an implementation for <code>Error::source()</code>, the blanket (default) implementation returns a <code>None</code>.</p>
<h2 id="raising-exceptions"><a class="header" href="#raising-exceptions">Raising exceptions</a></h2>
<p>To raise an exception in Java, throw an instance of the <code>Exception</code> class or any of the subclasses in its hierarchy:</p>
<pre><code class="language-java">static void throwIfNegative(int value) {
    if (value &lt; 0) {
        throw new IllegalArgumentException(&quot;Illegal argument value&quot;);
    }
}
</code></pre>
<p>For recoverable errors in Rust, return an <code>Ok</code> or <code>Err</code> variant from a method:</p>
<pre><code class="language-rust">fn error_if_negative(value: i32) -&gt; Result&lt;(), &amp;'static str&gt; {
    if value &lt; 0 {
        Err(&quot;Illegal argument value. (Parameter 'value')&quot;)
    } else {
        Ok(())
    }
}</code></pre>
<p>The <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> macro creates unrecoverable errors:</p>
<pre><code class="language-rust">fn panic_if_negative(value: i32) {
    if value &lt; 0 {
        panic!(&quot;Illegal argument value. (Parameter 'value')&quot;)
    }
}</code></pre>
<h2 id="error-propagation"><a class="header" href="#error-propagation">Error propagation</a></h2>
<p>In Java, exceptions are passed up the stack until they are handled or the
program terminates.</p>
<p>In Rust, unrecoverable errors behave similarly, but handling
them is uncommon. Recoverable errors, however, need to be propagated and handled explicitly. Their presence is always indicated by the Rust function or method signature.</p>
<p>Catching an exception allows you to take action based on the presence or absence of an
error in Java:</p>
<pre><code class="language-java">import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

static void write() {
    try {
        Files.write(
                Paths.get(&quot;file.txt&quot;),
                &quot;content to write&quot;.getBytes(),
                StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING
        );
    } catch (IOException e) {
        System.out.println(&quot;Writing to file failed.&quot;);
    }
}
</code></pre>
<p>In Rust, this is roughly equivalent to:</p>
<pre><code class="language-rust">fn write() {
    match std::fs::File::create(&quot;file.txt&quot;)
        .and_then(|mut file| std::io::Write::write_all(&amp;mut file, b&quot;content to write&quot;))
    {
        Ok(_) =&gt; {}
        Err(_) =&gt; println!(&quot;Writing to file failed.&quot;),
    };
}</code></pre>
<p>Frequently, recoverable errors need only be propagated instead of being handled.
For this, the method signature needs to be compatible with the types of the
propagated error. The <a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-"><code>?</code> operator</a> propagates errors
ergonomically:</p>
<pre><code class="language-rust">fn write() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut file = std::fs::File::create(&quot;file.txt&quot;)?;
    std::io::Write::write_all(&amp;mut file, b&quot;content to write&quot;)?;
    Ok(())
}</code></pre>
<p><strong>Note</strong>: To propagate an error with the question mark operator, the error
implementations need to be <em>compatible</em>, as described in <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"><em>a shortcut for
propagating errors</em></a>. The most general
&quot;compatible&quot; error type is the error <a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait object</a> <code>Box&lt;dyn Error&gt;</code>.</p>
<h2 id="stack-traces"><a class="header" href="#stack-traces">Stack traces</a></h2>
<p>Throwing an unhandled exception in Java will cause the runtime to print a stack
trace that allows debugging the problem with additional context.</p>
<p>For unrecoverable errors in Rust, <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#using-a-panic-backtrace"><code>panic!</code> backtraces</a> offer a
similar behavior.</p>
<p>Recoverable errors in stable Rust do not yet support Backtraces, but it is
currently supported in experimental Rust when using the <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.provide">provide method</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullability-and-optionality"><a class="header" href="#nullability-and-optionality">Nullability and Optionality</a></h1>
<p>Java has the <code>Optional&lt;T&gt;</code><sup class="footnote-reference"><a href="#optional">1</a></sup> utility class which represents a container object that may contain some value or null. In Java, <code>null</code> is often used to represent a value that is missing, absent or logically uninitialized. Here's an example of how we can use the Optional class:</p>
<pre><code class="language-java">Optional&lt;String&gt; some = Optional.ofNullable(&quot;John&quot;);
Optional&lt;String&gt; none = Optional.ofNullable(null);

System.out.println(some.isPresent()); // true
System.out.println(some.get()); // prints John
System.out.println(none.isEmpty()); // true
</code></pre>
<p>Rust has no <code>null</code>. Optional or missing values are represented by the <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a> type. The equivalent of the Java code above in Rust would be:</p>
<pre><code class="language-rust">let some: Option&lt;&amp;str&gt; = Some(&quot;John&quot;);
let none: Option&lt;&amp;str&gt; = None;

assert_eq!(some.is_some(), true); // ok
println!(&quot;{}&quot;, some.unwrap());  // prints John
assert_eq!(none.is_none(), true); // ok</code></pre>
<h2 id="control-flow-with-optionality"><a class="header" href="#control-flow-with-optionality">Control flow with optionality</a></h2>
<p>In Java, you may have used <code>if</code>/<code>else</code> statements to control the flow when using nullable values. For example:</p>
<pre><code class="language-java">String name = some Name object that may be null...

if (name != null) {
    // do something with the name variable e.g. print it
    System.out.println(name);
} else {
    // deal with the null case or print a default name
    System.out.println(&quot;John&quot;);
}
</code></pre>
<p>We can rewrite the code above to use the Optional class as follows:</p>
<pre><code class="language-java">String name = some Name object that may be null...

Optional&lt;String&gt; optionalName = Optional.ofNullable(name);

if (optionalName.isPresent()) {
    // do something with the name
    System.out.println(optionalName.get());
} else {
    // deal with the empty Optional or print a default name
    System.out.println(&quot;John&quot;);
}
</code></pre>
<p>In Rust, we can use pattern matching to achieve the same behavior:</p>
<pre><code class="language-rust">let name: Option&lt;&amp;str&gt; = Some(&quot;Arya&quot;);

match name {
    Some(name) =&gt; println!(&quot;{}&quot;, name),
    None =&gt; println!(&quot;John&quot;)  // if None, print default name instead
}</code></pre>
<p>We can also make the Java code even more succinct:</p>
<pre><code class="language-java">String name = some Name object that may be null...

String nameToPrint = Optional.ofNullable(name).orElse(&quot;John&quot;);

System.out.println(nameToPrint);
</code></pre>
<p>And the Rust code can be rewritten as below:</p>
<pre><code class="language-rust">let name: Option&lt;&amp;str&gt; = Some(&quot;Arya&quot;);

let name_to_print = name.unwrap_or(&quot;John&quot;); // if name is None, use default value

println!(&quot;{}&quot;, name_to_print);</code></pre>
<p><strong>Note</strong>: If the default value is expensive to compute, you can use <code>unwrap_or_else</code> instead. It takes a closure as an argument, which allows you to lazily initialize the default value.</p>
<p>If we only care about the presence of a value (rather than its absence), then we can write code like this in Java:</p>
<pre><code class="language-java">Optional&lt;String&gt; optionalName = Optional.of(&quot;Arya&quot;);

optionalName.ifPresent(name -&gt; System.out.println(&quot;The name is &quot; + name)); // prints: The name is Arya
</code></pre>
<p>The equivalent in Rust can be achieved using <code>if let</code>:</p>
<pre><code class="language-rust">let name = Some(&quot;Arya&quot;);

if let Some(name) = name {
    println!(&quot;The name is {}&quot;, name); // prints: The name is Arya
}</code></pre>
<hr />
<div class="footnote-definition" id="optional"><sup class="footnote-definition-label">1</sup>
<p>The <code>Optional</code> class was introduced in Java 8.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversion-and-casting"><a class="header" href="#conversion-and-casting">Conversion and Casting</a></h1>
<p>Both Java and Rust are statically-typed at compile time. Hence, after a variable
is declared, assigning a value of a different type (unless it's
implicitly convertible to the target type) to the variable is prohibited. There
are several ways to convert types in Java that have an equivalent in Rust.</p>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Implicit conversions exist in Java as well as in Rust (called <a href="https://doc.rust-lang.org/reference/type-coercions.html">type coercions</a>).
Consider the following example:</p>
<pre><code class="language-java">int intNumber = 1;
long longNumber = intNumber; // `int` is implicitly converted to `long`
</code></pre>
<p>Rust is much more restrictive with respect to which type coercions are allowed:</p>
<pre><code class="language-rust">let int_number: i32 = 1;
let long_number: i64 = int_number; // error: expected `i64`, found `i32`</code></pre>
<p>An example for a valid implicit conversion using <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md#subtyping">subtyping</a> is:</p>
<pre><code class="language-rust">fn bar&lt;'a&gt;() {
    let s: &amp;'static str = &quot;hi&quot;;
    let t: &amp;'a str = s;
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">Deref coercion</a></li>
<li><a href="https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance">Subtyping and variance</a></li>
</ul>
<h2 id="explicit-conversions"><a class="header" href="#explicit-conversions">Explicit conversions</a></h2>
<p>If converting could cause a loss of information, Java requires explicit conversions using a casting expression:</p>
<pre><code class="language-java">double a = 1.2;
int b = (int) a;
</code></pre>
<p>Rust does not provide coercion between primitive types, but instead uses
<a href="https://doc.rust-lang.org/rust-by-example/types/cast.html">explicit conversion</a> using the <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions"><code>as</code></a> keyword (casting).
Casting in Rust will not cause a panic.</p>
<pre><code class="language-rust">let int_number: i32 = 1;
let long_number: i64 = int_number as _;</code></pre>
<h2 id="custom-conversion"><a class="header" href="#custom-conversion">Custom conversion</a></h2>
<p>In Rust, the standard library contains an abstraction for converting a value
into a different type, in form of the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> trait and its
reciprocal, <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>. When implementing <code>From</code> for a type, a default
implementation for <code>Into</code> is automatically provided (called <em>blanket
implementation</em> in Rust). The following example illustrates two of such type
conversions:</p>
<pre><code class="language-rust">fn main() {
    let my_id = MyId(&quot;id&quot;.into()); // `into()` is implemented automatically due to the `From&lt;&amp;str&gt;` trait implementation for `String`.
    println!(&quot;{}&quot;, String::from(my_id)); // This uses the `From&lt;MyId&gt;` implementation for `String`.
}

struct MyId(String);

impl From&lt;MyId&gt; for String {
    fn from(MyId(value): MyId) -&gt; Self {
        value
    }
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> for versions of <code>From</code>
and <code>Into</code> which can fail.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotations"><a class="header" href="#annotations">Annotations</a></h1>
<p>In Java, annotations are a specialized kind of interface that allows you to add custom metadata about your code.</p>
<p>Here's an example of a method that's annotated with <code>@Test</code> to indicate that it's a test method:</p>
<pre><code class="language-java">@Test
public void someTestMethod() {
    // arrange
    // act
    // assert
}
</code></pre>
<p>The equivalent of annotations in Rust are called <em>attributes</em>. Here's a test method that is annotated with the <code>#[test]</code> attribute:</p>
<pre><code class="language-rust">#[test]
fn some_test_method() {
    // arrange
    // act
    // assert
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/attribute.html">Attributes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>Rust (like C++) has smart pointer types. Unlike a normal pointer (a memory address that points to some other data), a smart pointer is a data structure that not only acts as a pointer, but also has additional capabilities (and metadata).</p>
<p>Different smart pointers are defined in the Rust standard library. Some of the most common are:</p>
<ul>
<li><code>Box&lt;T&gt;</code> : for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>/ <code>Arc&lt;T&gt;</code> : reference counting type that enables multiple value ownership</li>
<li><code>RefCell&lt;T&gt;</code> : a type that enforces borrowing rules at runtime (and enables <em>interior mutability</em>)</li>
</ul>
<p>We are going to briefly look at the <code>Box&lt;T&gt;</code> type in this section. For more about smart pointers in Rust, see the <a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">Smart Pointers</a> chapter of the Rust book.</p>
<h2 id="using-boxt-to-store-data-on-the-heap"><a class="header" href="#using-boxt-to-store-data-on-the-heap">Using <code>Box&lt;T&gt;</code> to store data on the heap</a></h2>
<p>Consider this record type in Java:</p>
<pre><code class="language-java">record Point(double x, double y) {}

// create an instance of Point
Point p1 = new Point(10.5, 12.4);
Point p2 = new Point(10.5, 12.4);
Point p3 = new Point(14.2, 8.2);

System.out.println(p1); // prints: Point[x=10.5, y=12.4]

System.out.println(p1 == p2);      // false
System.out.println(p1.equals(p2)); // true
System.out.println(p1.equals(p3)); // false
</code></pre>
<p>The record class is a reference type in Java. Therefore, variable <code>p1</code> is a reference (pointer) to the object that is created using the <code>new</code> keyword. While the reference itself is stored on the stack, the object that it points to is allocated on the heap.</p>
<p>In Rust, structs are allocated on the stack by default. If you want to store the struct on the heap instead, then you'll have to <code>box</code> it (i.e. wrap it in a <code>Box&lt;T&gt;</code> smart pointer):</p>
<pre><code class="language-rust">#![allow(dead_code)]

#[derive(Debug, PartialEq)]
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // create an instance of Point struct
    let p1 = Point { x: 10.5, y: 12.4 }; // lives on the stack

    let p2 = Point { x: 10.5, y: 12.4 };

    let p3 = Box::new(Point { x: 10.5, y: 12.4 }); // allocate on the heap

    let p4 = Box::new(p1); // exactly the same as the line above

    println!(&quot;{:?}&quot;, p1); // prints: Point { x: 10.5, y: 12.4 }

    assert_eq!(p1, p2);  // ok
    assert_eq!(p1, p3);  // fails
    assert_eq!(p1, *p3); // ok, use the dereference operator (*) to get to the value stored on the heap
    assert_eq!(p3, p4);  // ok
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">Smart Pointers</a> chapter of the Rust book.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-comments"><a class="header" href="#documentation-comments">Documentation Comments</a></h1>
<p>Java provides a mechanism to document an API using a comment syntax that uses HTML text. The JDK comes with the <code>javadoc</code> tool that can be used to compile/generate HTML output for the doc comments.</p>
<p>Here's a simple example of a doc comment in Java:</p>
<pre><code class="language-java">/**
 * This is a doc comment for &lt;b&gt;MyClass&lt;/b&gt;.
 *
 */
public class MyClass {}
</code></pre>
<p>In Rust, <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">doc comments</a> provide the equivalent to Java doc comments.
Documentation comments in Rust use Markdown syntax. <a href="https://doc.rust-lang.org/rustdoc/index.html"><code>rustdoc</code></a> is the
documentation compiler for Rust code and is usually invoked through <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html"><code>cargo doc</code></a>, which compiles the comments into documentation.</p>
<p>Here's a simple example of a doc comment in Rust:</p>
<pre><code class="language-rust">/// This is a doc comment for `MyStruct`.
struct MyStruct;</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">How to write documentation</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">Documentation tests</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Like Java (and other languages with automatic memory management), Rust has <em>memory-safety</em> to avoid a whole class of bugs
related to memory access, and which end up being the source of many security
vulnerabilities in software. However, Rust can guarantee memory-safety at
<em>compile-time</em>; there is no run-time (like the JVM) making checks. The one
exception here is array bound checks that are done by the compiled code at
<em>run-time</em>. But unlike Java, it is also <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">possible to write unsafe code in Rust</a>, and the language has the <code>unsafe</code> keyword to mark
functions and blocks of code where memory-safety is no longer guaranteed.</p>
<p>Rust has no garbage collector (GC). All memory management is entirely the
responsibility of the developer. That said, <em>safe Rust</em> has rules around
ownership that ensure memory is freed <em>as soon as</em> it's no longer in use (e.g.
when leaving the scope of a block or a function). The compiler does a
tremendous job, through (compile-time) static analysis, of helping manage that
memory through <em>ownership rules</em>. If violated, the compiler rejects the code
with a compilation error.</p>
<p>In the JVM, there is no concept of ownership of memory beyond the GC roots
(static fields, local variables on a thread's stack, CPU registers, handles,
etc.). It is the GC that walks from the roots during a collection to detemine
all memory in use by following references and purging the rest. When designing
types and writing code, a Java developer can remain oblivious to ownership,
memory management and even how the garbage collector works for the most part,
except when performance-sensitive code requires paying attention to the amount
and rate at which objects are being allocated on the heap. In contrast, Rust's
ownership rules require the developer to explicitly think and express
ownership at all times and it impacts everything from the design of functions,
types, data structures to how the code is written. On top of that, Rust has
strict rules about how data is used such that it can identify at compile-time,
data <a href="https://doc.rust-lang.org/nomicon/races.html">race conditions</a> as well as corruption issues (requiring thread-safety)
that could potentially occur at run-time.</p>
<p>This section focuses on the following important concepts related to memory management in Rust:</p>
<ul>
<li><a href="memory-management/ownership.html">Ownership</a></li>
<li><a href="memory-management/references-and-lifetimes.html">References and Lifetimes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>Ownership is arguably one of Rust's most distinctive features. It allows Rust to make memory safety guarantees without needing a garbage collector.</p>
<p>In Rust, there can only be one owner of some memory, be that on the stack or heap, at any given time. Rust defines ownership rules that are enforced at compile time:</p>
<ul>
<li>Each value in Rust has a variable that's called it's <em>owner</em>.</li>
<li>There can be <em>only one owner</em> at a time.</li>
<li>When the owner goes out of scope, the value will be <em>dropped</em>.</li>
</ul>
<p>The Rust compiler assigns lifetimes and tracks ownership. It is possible to pass or yield ownership, which is called <em>moving</em> in Rust.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a> in Rust.</p>
</li>
</ul>
<p>Consider the following Java code that works without any errors:</p>
<pre><code class="language-java">record Point(int x, int y) {}

Point p1 = new Point(12, 10);
Point p2 = p1;

System.out.println(p1.x() + &quot;, &quot; + p1.y()); // prints: 12, 10
System.out.println(p2.x() + &quot;, &quot; + p2.y()); // prints: 12, 10
</code></pre>
<p>Now, let's look at the Rust version (fails with an error):</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 12, y: 10 }; // point owned by p1
    let p2 = p1;                     // ownership of point moved to p2 here

    println!(&quot;{}, {}&quot;, p1.x, p1.y);  // doesn't work, compiler error!
    println!(&quot;{}, {}&quot;, p2.x, p2.y);  // works fine, prints: 12, 10
}</code></pre>
<p>The first statement in <code>main</code> will allocate <code>Point</code> and that memory will be
owned by <code>p1</code>. In the second statement, the ownership is moved from <code>p1</code> to <code>p2</code> and <code>p1</code> can no longer be used because it no longer owns anything or represents valid memory. The statement that tries to print the fields of the point via <code>p1</code> will fail compilation.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>One way of making the code compile is by letting <code>p2</code> borrow the value of <code>p1</code> instead of taking ownership, as shown below. The ampersand (<code>&amp;</code>) indicates that <code>p2</code> takes a 
<em>reference</em> to the value of <code>p1</code>.</p>
<pre><code class="language-rust">fn main() {
    let p1 = Point { x: 12, y: 10 }; // point owned by p1
    let p2 = &amp;p1;                    // p2 &quot;borrows&quot; point, doen't take ownership

    println!(&quot;{}, {}&quot;, p1.x, p1.y);  // works fine, prints: 12, 10
    println!(&quot;{}, {}&quot;, p2.x, p2.y);  // works fine, prints: 12, 10
}</code></pre>
<h2 id="cloning"><a class="header" href="#cloning">Cloning</a></h2>
<p>Another alternative would be to <em>clone</em> <code>p1</code>:</p>
<pre><code class="language-rust">#[derive(Clone)] // this is required for cloning to work
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 12, y: 10 }; // point owned by p1
    
    let p2 = p1.clone(); // clone point instead of taking ownership

    println!(&quot;{}, {}&quot;, p1.x, p1.y);  // prints: 12, 10
    println!(&quot;{}, {}&quot;, p2.x, p2.y);  // prints: 12, 10
}</code></pre>
<blockquote>
<p>Note that the <code>Point</code> struct needs to implement/derive the <code>Clone</code> trait in order for cloning to work.</p>
</blockquote>
<h2 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h2>
<p>Let's look at this Rust code again:</p>
<pre><code class="language-rust">fn main() {
    let p1 = Point { x: 12, y: 10 }; // point owned by p1
    let p2 = p1;                     // p2 owns the point now

    println!(&quot;{}, {}&quot;, p2.x, p2.y);  // ok, uses p2
}   // point behind p2 is dropped</code></pre>
<p>When <code>main</code> exits, <code>p1</code> and <code>p2</code> will go out of scope. The memory
behind <code>p2</code> will be released by virtue of the stack returning to its state
prior to <code>main</code> being called. In Rust, one says that the point behind <code>p2</code> was <em>dropped</em>. However, note that since <code>p1</code> yielded its ownership of the point to <code>p2</code>, there is nothing to drop when <code>p1</code> goes out of scope.</p>
<p>A <code>struct</code> in Rust can define code to execute when an instance is dropped by
implementing the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait.</p>
<p>The rough equivalent of <em>dropping</em> in Java would be an object <em>finalizer</em>: the <code>finalize()</code> method<sup class="footnote-reference"><a href="#finalize">1</a></sup> provided by the root <code>Object</code> class, that is called before the object is garbage collected. While a finalizer would be called <em>automatically</em> by the GC at some future point, dropping in Rust is always instantaneous and deterministic; that is, it happens at the point the compiler has determined that an instance has no owner
based on scopes and lifetimes.</p>
<p>In Java, the equivalent of the <code>Drop</code> trait is the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html"><code>AutoCloseable</code></a> interface, and is implemented by types to release any unmanaged resources or memory they hold. <em>Deterministic disposal</em> is not enforced or guaranteed, but the <code>try-with-resources</code> statement in Java is typically used to scope an instance of an auto-closeable type such that it gets disposed deterministically, at the end of the <code>try-with-resources</code> statement's block.</p>
<p>In Java, references are shared freely without much thought so the idea
of a single owner and yielding/moving ownership may seem very limiting in
Rust, but it is possible to have <em>shared ownership</em> in Rust using the smart
pointer type <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc</code></a>; it adds reference-counting. Each time <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.clone">the smart pointer is cloned</a>, the reference count is incremented. When the
clone drops, the reference count is decremented. The actual instance behind
the smart pointer is dropped when the reference count reaches zero.</p>
<p>These points are illustrated by the following example that builds on the previous:</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

use std::rc::Rc;

struct Point {
    x: i32,
    y: i32,
}

impl Drop for Point {
    fn drop(&amp;mut self) {
        println!(&quot;Point dropped!&quot;);
    }
}

fn main() {
    let p1 = Rc::new(Point { x: 12, y: 10 });
    let p2 = Rc::clone(&amp;p1); // share with p2

    println!(&quot;p1 = {}, {}&quot;, p1.x, p1.y); // okay to use p1
    println!(&quot;p2 = {}, {}&quot;, p2.x, p2.y);
}

// prints:
// p1 = 12, 10
// p2 = 12, 10
// Point dropped!</code></pre>
<p>Note that:</p>
<ul>
<li>
<p><code>Point</code> implements the <code>drop</code> method of the <code>Drop</code> trait and prints a
message when an instance of a <code>Point</code> is dropped.</p>
</li>
<li>
<p>The point created in <code>main</code> is wrapped behind the smart pointer <code>Rc</code> and so
the smart pointer <em>owns</em> the point and not <code>p1</code>.</p>
</li>
<li>
<p><code>p2</code> gets a clone of the smart pointer that effectively increments the
reference count to 2. Unlike the earlier example, where <code>p2</code> transferred its
ownership of point to <code>p2</code>, both <code>p1</code> and <code>p2</code> own their own distinct clones of
the smart pointer, so it is okay to continue to use <code>p1</code> and <code>p2</code>.</p>
</li>
<li>
<p>The compiler will have determined that <code>p1</code> and <code>p2</code> go out of scope at the
end of <code>main</code> and therefore injected calls to drop each. The <code>Drop</code>
implementation of <code>Rc</code> will decrement the reference count and also drop what
it owns if the reference count has reached zero. When that happens, the
<code>Drop</code> implementation of <code>Point</code> will print the message, “Point
dropped!” The fact that the message is printed once demonstrates that
only one point was created, shared and dropped.</p>
</li>
</ul>
<p><code>Rc</code> is not thread-safe. For shared ownership in a multi-threaded program, the
Rust standard library offers <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> instead. The Rust language will
prevent the use of <code>Rc</code> across threads.</p>
<p>In Java, primitive types (like <code>int</code> and <code>double</code>) live on the stack and
reference types (like <code>class</code>, <code>interface</code>, and <code>record</code>) are heap-allocated. In Rust, the kind of type (basically <code>enum</code> or <code>struct</code>), does not determine where the backing memory will eventually live. By default, it is always on the stack, but just the way Java has the notion of autoboxing of primitive types, the way to allocate a type on the heap is to box it using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>:</p>
<pre><code class="language-rust">let stack_point = Point { x: 12, y: 10 };
let heap_point = Box::new(Point { x: 12, y: 10 });</code></pre>
<p>Like <code>Rc</code> and <code>Arc</code>, <code>Box</code> is a smart pointer, but unlike <code>Rc</code> and <code>Arc</code>, it
exclusively owns the instance behind it. All of these smart pointers allocate
an instance of their type argument <code>T</code> on the heap.</p>
<p>The <code>new</code> keyword in Java creates an instance of a type, and while members such
as <code>Box::new</code> and <code>Rc::new</code> that you see in the examples may seem to have a
similar purpose, <code>new</code> has no special designation in Rust. It's merely a
<em>conventional name</em> that is meant to denote a factory. In fact they are called
<em>associated functions</em> of the type, which is Rust's way of saying <em>static</em>
methods.</p>
<hr />
<div class="footnote-definition" id="finalize"><sup class="footnote-definition-label">1</sup>
<p>The <code>finalization</code> mechanism has been deprecated since Java 9. In modern Java, the preferred approach for resource management is by the use of <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ref/Cleaner.html">cleaners</a>, or <a href="https://dev.java/learn/catching-and-handling-exceptions/#anchor_6">try-with-resources</a> statement.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-and-lifetimes"><a class="header" href="#references-and-lifetimes">References and Lifetimes</a></h1>
<p>Consider this Rust code:</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 12, y: 10 };
    let p2 = &amp;p1; // p2 takes a reference to the value of p1

    assert_eq!(Point { x: 12, y: 10 }, p1);  // ok
    assert_eq!(Point { x: 12, y: 10 }, p2);  // fails
    assert_eq!(Point { x: 12, y: 10 }, *p2); // ok, we use the dereference operator (*) to get the value
}</code></pre>
<p>In Rust, references allow you to <em>refer</em> to some value without taking ownership of it. References are indicated by the use of an ampersand (<code>&amp;</code>). In order to get to the value that a reference points to, we use the dereference operator (<code>*</code>).</p>
<p>Consider the following <code>Rectangle</code> struct and its implementation block:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: i32,
    width: i32,
}

impl Rectangle {
    pub fn new(length: i32, width: i32) -&gt; Self {
        Self { length, width }
    }

    pub fn length(&amp;self) -&gt; i32 {
        self.length
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.width
    }
}</code></pre>
<p>Here's a function to calculate the area of a rectangle. Notice that we are passing in the <code>Rectangle</code> by value:</p>
<pre><code class="language-rust">fn calculate_area(rect: Rectangle) -&gt; i32 {
    rect.length() * rect.width()
}</code></pre>
<p>When we exercise the function as shown below, we get an error. Because we are passing 
<em>by value</em>, ownership of rect is <em>moved into</em> the <code>calculate_area()</code> function:</p>
<pre><code class="language-rust">fn main() {
    let rect = Rectangle::new(6, 4);
    
    
    let area_of_rect = calculate_area(rect); // value moved into function
    
    
    println!(&quot;{}&quot;, area_of_rect); // prints: 24
    println!(&quot;{:?}&quot;, rect);       // won't work, rect no longer available here
}</code></pre>
<p>One (inefficient) solution would be to make <code>Rectangle</code> <em>cloneable</em>:</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
struct Rectangle {
    length: i32,
    width: i32,
}

fn main() {
    let rect = Rectangle::new(6, 4);
    
    let area_of_rect = calculate_area(rect.clone());

    println!(&quot;{}&quot;, area_of_rect); // prints: 24
    println!(&quot;{:?}&quot;, rect);       // works fine, prints: Rectangle { length: 6, width: 4 }
}</code></pre>
<p>When we are dealing with a lot of objects, then cloning wouldn't be a great solution.</p>
<p>A better approach would be to make the <code>calculate_area()</code> function take a <em>reference</em> to the <code>Rectangle</code> (i.e. <code>&amp;Rectangle</code>) as input. In other words, pass the value <em>by reference</em>.</p>
<pre><code class="language-rust">fn calculate_area(rect: &amp;Rectangle) -&gt; i32 {
    rect.length() * rect.width()
}</code></pre>
<p>And now we can use the function as follows:</p>
<pre><code class="language-rust">#[derive(Debug)] // no more Clone
struct Rectangle {
    length: i32,
    width: i32,
}

fn main() {
    let rect = Rectangle::new(6, 4);
    
    
    let area_of_rect = calculate_area(&amp;rect); // takes a reference as input
    
    
    println!(&quot;{}&quot;, area_of_rect); // prints: 24
    println!(&quot;{:?}&quot;, rect);       // works fine, prints: Rectangle { length: 6, width: 4 }
}</code></pre>
<p>Finally, let's consider the following case that doesn't compile:</p>
<pre><code class="language-rust">fn main() {
    let rect1;
    
    {
        let rect2 = Rectangle::new(6, 4);
        rect1 = &amp;rect2;
    } // rect2 goes out of scope/is dropped here
    
    // rect1, which holds a reference to rect2 is invalid here
    println!(&quot;{:?}&quot;, rect1); // won't work: borrowed value (&amp;rect2) does not live long enough
}</code></pre>
<p>Here's the same code with <em>lifetime</em> annotations:</p>
<pre><code class="language-rust">fn main() {
    let rect1;                            // -----------+--- 'a
                                          //            |
    {                                     //            |  
        let rect2 = Rectangle::new(6, 4); // --+-- 'b   |
        rect1 = &amp;rect2;                   //   |        |
    }                                     // --+        |
                                          //            |
    println!(&quot;{:?}&quot;, rect1);              //            |
}                                         // -----------+</code></pre>
<p>As you can see, the lifetime of rect2 (<code>'b</code>) is shorter than that of rect1 (<code>'a</code>). That's what the error message indicates: <code>borrowed value (&amp;rect2) does not live long enough</code>. Therefore trying to access rect2 after it's been dropped results in a compile-time error.</p>
<blockquote>
<p>The lifetime annotation <code>'a</code> is pronounced &quot;<em>tick A</em>&quot;.</p>
</blockquote>
<p>The Rust compiler has a <em>borrow checker</em> that keeps track of variable lifetimes to determine whether all borrows are valid.</p>
<p>The version below works fine:</p>
<pre><code class="language-rust">fn main() {
    let rect2 = Rectangle::new(6, 4); // -----------+--- 'b
                                      //            |
    let rect1 = &amp;rect2;               // --+-- 'a   |  
                                      //   |        |
    println!(&quot;{:?}&quot;, rect1);          //   |        |
                                      //---+        |
}                                     // -----------+</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">Lifetimes</a> in Rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h1>
<p>The previous section on <a href="resource-management/../memory-management/index.html">memory management</a> explains the differences between Java
and Rust when it comes to GC, ownership and finalizers. It is highly recommended that you read it.</p>
<p>This section is limited to providing an example of a fictional
<em>database connection</em> involving a SQL connection to be properly
closed/disposed/dropped.</p>
<p>Here's the Java version:</p>
<pre><code class="language-java">import java.sql.Connection;

public class DatabaseConnection implements AutoCloseable {

    final String connectionString;
    Connection connection; // the Connection type implements AutoCloseable

    public DatabaseConnection(String connectionString) {
        this.connectionString = connectionString;
    }

    @Override
    public void close() throws Exception {
        // making sure to close the Connection
        this.connection.close();
        System.out.println(&quot;Closing connection: &quot; + this.connectionString);
    }
}

// try-with-resources statement
try (
        var db1 = new DatabaseConnection(&quot;server=A; database=db1&quot;);
        var db2 = new DatabaseConnection(&quot;server=A; database=db2&quot;)
        ) {
    // ...code using &quot;db1&quot; and &quot;db2&quot;...
} // &quot;close()&quot; of &quot;db1&quot; and &quot;db2&quot; called here; when their scope ends
</code></pre>
<p>And here's the Rust equivalent:</p>
<pre><code class="language-rust">struct DatabaseConnection(&amp;'static str);

impl DatabaseConnection {
    // ...functions for using the database connection...
}

impl Drop for DatabaseConnection {
    fn drop(&amp;mut self) {
        // ...closing connection...
        self.close_connection();
        // ...printing a message...
        println!(&quot;Closing connection: {}&quot;, self.0)
    }
}

fn main() {
    let _db1 = DatabaseConnection(&quot;Server=A;Database=DB1&quot;);
    let _db2 = DatabaseConnection(&quot;Server=A;Database=DB2&quot;);
    // ...code for making use of the database connection...
} // &quot;Dispose&quot; of &quot;db1&quot; and &quot;db2&quot; called here; when their scope ends</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threading-and-concurrency"><a class="header" href="#threading-and-concurrency">Threading and Concurrency</a></h1>
<p>The Rust standard library supports threading, synchronization and concurrency. Even though the language itself and the standard library do have basic support for these concepts, a lot of additional functionality is provided by crates and will not be covered in this section.</p>
<p>This section focuses on the following concepts related to threading and concurrency:</p>
<ul>
<li><a href="threading-and-concurrency/threads.html">Threads</a></li>
<li><a href="threading-and-concurrency/synchronization.html">Synchronization</a></li>
<li><a href="threading-and-concurrency/producer-consumer.html">Producer-Consumer Pattern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>The following table lists approximate mapping of threading types and methods in Java to Rust:</p>
<div class="table-wrapper"><table><thead><tr><th>Java</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>Thread</code></td><td><code>std::thread::Thread</code></td></tr>
<tr><td><code>Thread.start</code></td><td><code>std::thread::spawn</code></td></tr>
<tr><td><code>Thread.join</code></td><td><code>std::thread::JoinHandle</code></td></tr>
<tr><td><code>Thread.sleep</code></td><td><code>std::thread::sleep</code></td></tr>
<tr><td><code>synchronized</code></td><td>-</td></tr>
<tr><td><code>ReentrantLock</code></td><td><code>std::sync::Mutex</code></td></tr>
<tr><td><code>ReentrantReadWriteLock</code></td><td><code>std::sync::RwLock</code></td></tr>
<tr><td><code>Semaphore</code></td><td>-</td></tr>
<tr><td><code>Condition</code></td><td><code>std::sync::Condvar</code></td></tr>
<tr><td><code>java.util.concurrent.atomic.*</code></td><td><code>std::sync::atomic</code></td></tr>
<tr><td><code>volatile</code></td><td>-</td></tr>
<tr><td><code>ThreadLocal</code></td><td><code>std::thread_local</code></td></tr>
</tbody></table>
</div>
<p>Launching a thread and waiting for it to finish works the same way in Java
and Rust. Below is a simple Java program that creates a thread and then waits for it to end:</p>
<pre><code class="language-java">Thread thread = new Thread(() -&gt; {
                System.out.println(&quot;Hello from a thread!&quot;); });

thread.start();
thread.join();  // wait for thread to finish
</code></pre>
<p>The same code in Rust looks as follows:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let thread = thread::spawn(|| println!(&quot;Hello from a thread!&quot;));
    thread.join().unwrap(); // wait for thread to finish
}</code></pre>
<p>Creating and initializing a thread object and starting a thread are two
different actions in Java whereas in Rust both happen at the same time with
<code>thread::spawn</code>.</p>
<p>Java 21 introduced the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.Builder.html">Thread.Builder</a> API for creating and starting both 
<em>platform</em> and <em>virtual</em> threads. Platform threads are the traditional threads in Java that are thin wrappers around OS threads - the thread that we created above is an example of a platform thread. <a href="https://openjdk.org/jeps/444">Virtual threads</a> on the other hand are lightweight threads that are not directly tied to OS threads.</p>
<p>Here's how we can use the thread builder API to create a platform thread in Java:</p>
<pre><code class="language-java">Thread platformThread = Thread.ofPlatform().unstarted(() -&gt; {
                        System.out.println(&quot;Hello from a platform thread!&quot;); });

platformThread.start();
platformThread.join();
</code></pre>
<p>And here's how we can create a virtual thread:</p>
<pre><code class="language-java">Thread virtualThread = Thread.ofVirtual().unstarted(() -&gt; {
                       System.out.println(&quot;Hello from a virtual thread!&quot;); });

virtualThread.start();
virtualThread.join();
</code></pre>
<blockquote>
<p>Note: Rust does not have support for virtual threads.</p>
</blockquote>
<h2 id="working-with-thread-pools"><a class="header" href="#working-with-thread-pools">Working with thread pools</a></h2>
<p>In Java, we can create a thread pool using the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html">Executor framework</a>.</p>
<p>Consider the following Java example:</p>
<pre><code class="language-java">static void concurrentProcessing() throws ExecutionException, InterruptedException {

    // Using Callable so a value can be returned after processing by a thread
    Callable&lt;Integer&gt; sportsNews =  () -&gt; {
        for (int i = 0; i &lt; 10; i++) {
            Thread.sleep(1000); // sleep for 1 second
            System.out.println(&quot;Manchester United is winning &quot; + i);
        }
        // Just return some random number to illustrate return
        return 42;
    };

    Callable&lt;Integer&gt; leaguePoints =  () -&gt; {
        for (int i = 0; i &lt; 10; i++) {
            Thread.sleep(700); // sleep for 700 milliseconds
            int points = 40 + i;
            System.out.println(&quot;Manchester has &quot; + points + &quot; league points&quot;);
        }
        // Just return some random number
        return 24;
    };

    // A placeholder for Future objects
    List&lt;Future&lt;Integer&gt;&gt; futures = new ArrayList&lt;&gt;();

    // A temporary storage for results returned by threads
    List&lt;Integer&gt; results = new ArrayList&lt;&gt;();

    try (
        final ExecutorService service = Executors.newFixedThreadPool(2); // Create a pool of 2 threads
        ) {

        futures.add(service.submit(sportsNews));
        futures.add(service.submit(leaguePoints));

        for (var future : futures) {
            results.add(future.get());
        }
    }

    for (Integer result : results) {
        System.out.println(&quot;Got the result: &quot; + result);
    }
}

public static void main(String[] args) {

    try {
        concurrentProcessing();
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }

}
</code></pre>
<p>Here's the output of running the Java code above:</p>
<pre><code>Manchester has 40 league points
Manchester United is winning 0
Manchester has 41 league points
Manchester United is winning 1
Manchester has 42 league points
Manchester has 43 league points
Manchester United is winning 2
Manchester has 44 league points
Manchester United is winning 3
Manchester has 45 league points
Manchester has 46 league points
Manchester United is winning 4
Manchester has 47 league points
Manchester United is winning 5
Manchester has 48 league points
Manchester United is winning 6
Manchester has 49 league points
Manchester United is winning 7
Manchester United is winning 8
Manchester United is winning 9
Got the result: 42
Got the result: 24
</code></pre>
<blockquote>
<p>Note: Your output might look slighly different.</p>
</blockquote>
<p>Here's the Rust version of the code. We are using the <a href="https://docs.rs/rayon/latest/rayon/index.html">Rayon library</a> to create a thread pool.</p>
<pre><code class="language-rust">use std::{thread, time};
use std::sync::Mutex;

fn sports_news() -&gt; i32 {
    for i in 0..10 {
        let seconds = time::Duration::from_millis(1000);
        thread::sleep(seconds); // sleep for 1 second
        println!(&quot;Manchester United is winning {}&quot;, i);
    }
    
    // Just return some number to illustrate return
    return 42;
}

fn league_points() -&gt; i32 {
    for i in 0..10 {
        let seconds = time::Duration::from_millis(700);
        thread::sleep(seconds); // sleep for 700 milliseconds
        let points = 40 + i;
        println!(&quot;Manchester has {} league points&quot;, points);
    }
    
    // Just return some number
    return 24;
}

fn concurrent_processing() {
    // A temporary storage for results returned by threads
    let result_vec = Mutex::new(Vec::new());

    let pool = rayon::ThreadPoolBuilder::new()
        .num_threads(2) // Create a pool of 2 threads
        .build()
        .unwrap();

    pool.install(|| {

        rayon::scope(|s| {
            
            let result_vec = &amp;result_vec;

            // spawn thread to process sports news
            s.spawn(move |_| {
                let result1 = sports_news();
                
                result_vec.lock().unwrap().push(result1);
            });

            // spawn thread to process league points
            s.spawn(move |_| {
                let result2 = league_points();
                
                result_vec.lock().unwrap().push(result2);
            });
    
        });
    });
    
    for result in result_vec.lock().unwrap().iter() {
        println!(&quot;Got the result: {:?}&quot;, result);
    }
}

fn main() {
    
    concurrent_processing();
    
}</code></pre>
<p>Here's the output of the Rust code above:</p>
<pre><code>Manchester has 40 league points
Manchester United is winning 0
Manchester has 41 league points
Manchester United is winning 1
Manchester has 42 league points
Manchester has 43 league points
Manchester United is winning 2
Manchester has 44 league points
Manchester United is winning 3
Manchester has 45 league points
Manchester has 46 league points
Manchester United is winning 4
Manchester has 47 league points
Manchester United is winning 5
Manchester has 48 league points
Manchester United is winning 6
Manchester has 49 league points
Manchester United is winning 7
Manchester United is winning 8
Manchester United is winning 9
Got the result: 24
Got the result: 42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h1>
<p>When data is shared between threads, one needs to synchronize read-write
access to the data in order to avoid corruption. Java offers the <code>synchronized</code>
keyword as a synchronization primitive. When we use a synchronized block, Java internally uses a <a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">monitor</a>, also known as a <em>monitor lock</em> to provide synchronization:</p>
<pre><code class="language-java">public class ExampleClass {

    static int data = 0;

    public static void main(String[] args) throws InterruptedException {

        var dataLock = new Object(); // declare a monitor lock object

        var threads = new ArrayList&lt;Thread&gt;();

        for (var i = 0; i &lt; 10; i++) {
            var thread =  new Thread(() -&gt; {
                for (var j = 0; j &lt; 1000; j++) {
                    synchronized (dataLock) {
                        data++;
                    }
                }
            });

            threads.add(thread);
            thread.start();
        }

        for (var thread : threads) {
            thread.join();
        }

        System.out.println(data); // prints: 10000
    }
}
</code></pre>
<p>In Rust, one must make explicit use of concurrency structures like <code>Mutex</code>:</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let data = Arc::new(Mutex::new(0)); // (1)

    let mut threads = vec![];
    for _ in 0..10 {
        let data = Arc::clone(&amp;data); // (2)
        let thread = thread::spawn(move || { // (3)
            for _ in 0..1000 {
                let mut data = data.lock().unwrap();
                *data += 1; // (4)
            }
        });
        threads.push(thread);
    }

    for thread in threads {
        thread.join().unwrap();
    }

    println!(&quot;{}&quot;, data.lock().unwrap()); // prints: 10000
}</code></pre>
<p>A few things to note:</p>
<ul>
<li>
<p>Since the ownership of the <code>Mutex</code> instance and in turn the data it guards
will be shared by multiple threads, it is wrapped in an <code>Arc</code> (1). <code>Arc</code>
provides <em>atomic reference counting</em>, which increments each time it is cloned
(2) and decrements each time it is dropped. When the count reaches zero, the
mutex and in turn the data it guards are dropped.</p>
</li>
<li>
<p>The closure instance for each thread receives ownership (3) of the <em>cloned
reference</em> (2).</p>
</li>
<li>
<p>The <code>move</code> keyword (3) is <em>required</em> to <em>move</em> or pass the ownership of <code>data</code> (2) to 
the closure for the thread.</p>
</li>
<li>
<p>The pointer-like code that is <code>*data += 1</code> (4), is not some unsafe pointer
access even if it looks like it. It's updating the data <em>wrapped</em> in the
<a href="https://doc.rust-lang.org/stable/std/sync/struct.MutexGuard.html">mutex guard</a>.</p>
</li>
</ul>
<p>Unlike the Java version, where one can render it <em>thread-unsafe</em> by commenting out
the <code>synchronized</code> statement, the Rust version will refuse to compile if it's changed
in any way (e.g. by commenting out parts that renders it thread-unsafe). This
demonstrates that writing thread-safe code is the developer's responsibility
in Java, by careful use of synchronized structures, whereas in Rust, one
can rely on the compiler to enforce <em>thread-safety</em>.</p>
<p>The compiler is able to help because data structures in Rust are marked by
special traits: <code>Sync</code> and <code>Send</code>. <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a> indicates that references to a type's instances are safe to share between threads. <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> indicates that it's safe to send instances of a type across thread boundaries. For more information, see the “<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">Fearless Concurrency</a>” chapter of the Rust book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="producer-consumer-pattern"><a class="header" href="#producer-consumer-pattern">Producer-Consumer Pattern</a></h1>
<p>The producer-consumer pattern is a very common pattern for distributing work between threads where data is passed from producing threads to consuming threads without the need for sharing or locking. Java provides support for this pattern. The 
<code>java.util.concurrent</code> package provides the <code>BlockingQueue</code> interface that can be used to implement this pattern:</p>
<pre><code class="language-java">public class ExampleClass {

    public static void main(String[] args) throws InterruptedException {

        BlockingQueue&lt;String&gt; messages = new LinkedBlockingQueue&lt;&gt;();

        AtomicBoolean isComplete = new AtomicBoolean(false);

        Thread producer = new Thread(() -&gt; {
            try {
                for (int i = 1; i &lt; 10; i++) {
                    messages.put(&quot;Message #&quot; + i); // add a message to the queue
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                isComplete.set(true);
            }
        });

        producer.start();

        // Main thread is the consumer here
        while (!isComplete.get() || !messages.isEmpty()) {
            try {
                String message = messages.take(); // get a message from the queue
                System.out.println(&quot;The message received is: &quot; + message);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        producer.join();
    }
}
</code></pre>
<p>The output of the code above looks as follows:</p>
<pre><code>The message received is: Message #1
The message received is: Message #2
The message received is: Message #3
The message received is: Message #4
The message received is: Message #5
The message received is: Message #6
The message received is: Message #7
The message received is: Message #8
The message received is: Message #9
</code></pre>
<p>The same result can be achieved in Rust by using <em>channels</em>. The standard library primarily
provides <code>mpsc::channel</code>, which is a channel that supports multiple producers and a single consumer. A rough translation of the above Java example in Rust would look as follows:</p>
<pre><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel(); // create a message channel

    let producer = thread::spawn(move || {
        for i in 1..10 {
            tx.send(format!(&quot;Message #{}&quot;, i)).unwrap(); // send a message to the channel
        }
    });

    // main thread is the consumer here
    for received in rx {
        println!(&quot;The message received is: {}&quot;, received);
    }

    producer.join().unwrap();
}</code></pre>
<p>The output for the Rust code above is as follows:</p>
<pre><code>The message received is: Message #1
The message received is: Message #2
The message received is: Message #3
The message received is: Message #4
The message received is: Message #5
The message received is: Message #6
The message received is: Message #7
The message received is: Message #8
The message received is: Message #9
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="test-organization"><a class="header" href="#test-organization">Test organization</a></h2>
<p>Conventionally, Java projects use separate files to host test code, irrespective of the
test framework being used and the type of tests being written (unit or integration). The test code therefore lives in a separate file (or package) from the application or library code being tested.</p>
<p>In Rust, it is a lot more conventional for <em>unit tests</em> to be found in a separate test sub-module (conventionally) named <code>tests</code>, but which is placed in the same <em>source file</em> as the application or library module code that is the subject of the
tests. One advantage of this is that the code/module and its unit tests live side-by-side.</p>
<p>The test sub-module is annotated with the <code>#[cfg(test)]</code> attribute, which has
the effect that the entire module is (conditionally) compiled and run only
when the <code>cargo test</code> command is issued.</p>
<p>Within the test sub-modules, test functions are annotated with the <code>#[test]</code>
attribute.</p>
<p>Integration tests are usually in a directory called <code>tests</code> that sits adjacent
to the <code>src</code> directory with the unit tests and source. <code>cargo test</code> compiles
each file in that directory as a separate crate and runs all the methods
annotated with the <code>#[test]</code> attribute. Since it is understood that integration
tests are in the <code>tests</code> directory, there is no need to mark the modules in there
with the <code>#[cfg(test)]</code> attribute.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">Test Organization</a> in Rust projects.</p>
</li>
</ul>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p>When using a build tool like Maven in Java, you can run tests using <code>mvn test</code>.</p>
<p>In Rust, you run tests by using <code>cargo test</code>.</p>
<p>The default behavior of <code>cargo test</code> is to run all the tests in parallel, but this can be configured to run consecutively using only a single thread:</p>
<pre><code>cargo test -- --test-threads=1
</code></pre>
<p>For more information, see &quot;<a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively">Running Tests in Parallel or
Consecutively</a>&quot;.</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>Java users have multiple ways to assert, depending on the framework being
used. For example, an assertion in JUnit might look like this:</p>
<pre><code class="language-java">@Test
public void somethingIsTheRightLength() {
    String value = &quot;something&quot;;
    assertEquals(9, value.length());
}
</code></pre>
<p>Rust does not require a separate framework or crate. The standard library
comes with built-in <em>macros</em> that are good enough for most assertions in
tests:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a></li>
<li><a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a></li>
<li><a href="https://doc.rust-lang.org/std/macro.assert_ne.html"><code>assert_ne!</code></a></li>
</ul>
<p>Below is an example of <code>assert_eq!</code> in action:</p>
<pre><code class="language-rust">#[test]
fn something_is_the_right_length() {
    let value = &quot;something&quot;;
    assert_eq!(9, value.len());
}</code></pre>
<h2 id="mocking"><a class="header" href="#mocking">Mocking</a></h2>
<p>When writing tests for a Java application or library, there exist several
frameworks, like <a href="https://site.mockito.org/">Mockito</a>, to mock out the dependencies. There are similar crates for Rust too, like <a href="https://docs.rs/mockall/latest/mockall/"><code>mockall</code></a>, that can help with mocking. However, it is also possible to use <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a> by making use of the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> as a simple means to mocking without needing to rely on external crates or frameworks. The <code>cfg</code> attribute conditionally includes the code it annotates based on a configuration symbol, such as <code>test</code> for testing. This is not very different to using <code>DEBUG</code> to conditionally compile code specifically for debug builds. One downside of this approach is that you can only have one implementation for all tests of the module.</p>
<p>The example below shows mocking of a stand-alone function <code>var_os</code> from the
standard library that reads and returns the value of an environment variable. It
conditionally imports a mocked version of the <code>var_os</code> function used by
<code>get_env</code>. When built with <code>cargo build</code> or run with <code>cargo run</code>, the compiled
binary will make use of <code>std::env::var_os</code>, but <code>cargo test</code> will instead
import <code>tests::var_os_mock</code> as <code>var_os</code>, thus causing <code>get_env</code> to use the
mocked version during testing:</p>
<pre><code class="language-rust">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

/// Utility function to read an environment variable and return its value If
/// defined. It fails/panics if the valus is not valid Unicode.
pub fn get_env(key: &amp;str) -&gt; Option&lt;String&gt; {
    #[cfg(not(test))]                 // for regular builds...
    use std::env::var_os;             // ...import from the standard library
    #[cfg(test)]                      // for test builds...
    use tests::var_os_mock as var_os; // ...import mock from test sub-module

    let val = var_os(key);
    val.map(|s| s.to_str()     // get string slice
                 .unwrap()     // panic if not valid Unicode
                 .to_owned())  // convert to &quot;String&quot;
}

#[cfg(test)]
mod tests {
    use std::ffi::*;
    use super::*;

    pub(crate) fn var_os_mock(key: &amp;str) -&gt; Option&lt;OsString&gt; {
        match key {
            &quot;FOO&quot; =&gt; Some(&quot;BAR&quot;.into()),
            _ =&gt; None
        }
    }

    #[test]
    fn get_env_when_var_undefined_returns_none() {
        assert_eq!(None, get_env(&quot;???&quot;));
    }

    #[test]
    fn get_env_when_var_defined_returns_some_value() {
        assert_eq!(Some(&quot;BAR&quot;.to_owned()), get_env(&quot;FOO&quot;));
    }
}</code></pre>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code coverage</a></h2>
<p>The Java ecosystem has several tools for analyzing test code coverage. One such popular tool is <a href="https://www.eclemma.org/jacoco/"><code>JaCoCo</code></a>. In IDEs like IntelliJ, code coverage tooling is built-in and integrated.</p>
<p>Rust provides <a href="https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#test-coverage">built-in code coverage implementations</a> for
collecting test code coverage.</p>
<p>There are also plug-ins available for Rust to help with code coverage analysis.
It's not seamlessly integrated, but with some manual steps, developers can
analyze their code in a visual way.</p>
<p>The combination of <a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">Coverage Gutters</a> plug-in for Visual
Studio Code and <a href="https://github.com/xd009642/tarpaulin">Tarpaulin</a> allows visual analysis of the code coverage in
Visual Studio Code. Coverage Gutters requires an LCOV file. Other tools besides Tarpaulin can be used to generate that file.</p>
<p>Once setup, run the following command:</p>
<pre><code class="language-bash">cargo tarpaulin --ignore-tests --out Lcov
</code></pre>
<p>This generates an LCOV Code Coverage file. Once <code>Coverage Gutters: Watch</code> is
enabled, it will be picked up by the Coverage Gutters plug-in, which will show
in-line visual indicators about the line coverage in the source code editor.</p>
<blockquote>
<p>Note: The location of the LCOV file is essential. If a workspace (see <a href="testing/../project-structure/index.html">Project
Structure</a>) with multiple packages is present and a LCOV file is generated in
the root using <code>--workspace</code>, that is the file that is being used - even if
there is a file present directly in the root of the package. It is quicker to
isolate to the particular package under test rather than generating the LCOV
file in the root.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<p>Running benchmarks in Rust is done via <a href="https://doc.rust-lang.org/cargo/commands/cargo-bench.html"><code>cargo bench</code></a>, a specific
command for <code>cargo</code> which executes all the methods annotated with the
<code>#[bench]</code> attribute. This attribute is currently <a href="https://doc.rust-lang.org/rustc/tests/index.html#test-attributes">unstable</a> and
available only for the nightly channel.</p>
<p>Java users can make use of the <code>Java Microbenchmark Harness (JMH)</code> tool to write microbenchmarks for their Java code. The equivalent of <code>JMH</code> for Rust is a crate named
<code>Criterion</code>.</p>
<p>As per its <a href="https://bheisler.github.io/criterion.rs/book/index.html">documentation</a>, <code>Criterion</code> collects and stores
statistical information from run to run and can automatically detect performance
regressions as well as measuring optimizations.</p>
<p>With <code>Criterion</code>, it is possible to use the <code>#[bench]</code> attribute without moving to
the nightly channel.</p>
<p>It is possible to integrate benchmark results with the <a href="https://github.com/benchmark-action/github-action-benchmark">GitHub Action for Continuous Benchmarking</a>. <code>Criterion</code>, in fact, supports multiple output formats, amongst which there is also the <code>bencher</code> format, mimicking the nightly <code>libtest</code> benchmarks and compatible with the mentioned action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-and-tracing"><a class="header" href="#logging-and-tracing">Logging and Tracing</a></h1>
<p>Java comes with a logging API, which is ideal for simple use-cases. Apart from the logging API, there are other logging frameworks for Java, like <code>Log4J</code> and 
<code>Logback</code>. The <code>Simple Logging Facade for Java (SLF4J)</code> provides an abstraction layer that allows you to easily switch logging frameworks if needed.</p>
<p>In Java, a minimal example for structured logging using the logging API could look like this:</p>
<pre><code class="language-java">import java.util.logging.Logger;

public class ExampleLogger {
    
    private static final Logger LOGGER = Logger.getLogger(ExampleLogger.class.getName());

    public static void main(String[] args) {
        LOGGER.info(&quot;Printing Hello World&quot;);

        System.out.println(&quot;Hello World&quot;);
    }
}
</code></pre>
<p>In Rust, a lightweight logging facade is provided by <a href="https://crates.io/crates/log">log</a>. This can be used for relatively simple logging use-cases.</p>
<p>For something with more features like some of the Java logging frameworks, Tokio offers <a href="https://crates.io/crates/tracing"><code>tracing</code></a>. <code>tracing</code> is a framework for instrumenting Rust applications to collect structured, event-based diagnostic information. <a href="https://docs.rs/tracing-subscriber/latest/tracing_subscriber/"><code>tracing_subscriber</code></a> can be used to implement and compose <code>tracing</code> subscribers. The same structured logging example from above with <code>tracing</code> and <code>tracing_subscriber</code> looks like this:</p>
<pre><code class="language-rust">fn main() {
    // install global default (&quot;console&quot;) collector.
    tracing_subscriber::fmt().init();
    tracing::info!(&quot;Printing Hello World&quot;);

    println!(&quot;Hello World&quot;);
}</code></pre>
<p><a href="https://crates.io/crates/opentelemetry">OpenTelemetry</a> offers a collection of tools, APIs, and SDKs
used to instrument, generate, collect, and export telemetry data based on the
OpenTelemetry specification. At the time of writing, the <a href="https://opentelemetry.io/docs/reference/specification/status/#logging">OpenTelemetry Logging
API</a> is not yet stable and the Rust implementation <a href="https://opentelemetry.io/docs/instrumentation/rust/#status-and-releases">does
not yet support logging</a>, but the tracing API is
supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-and-configuration"><a class="header" href="#environment-and-configuration">Environment and Configuration</a></h1>
<h2 id="accessing-environment-variables"><a class="header" href="#accessing-environment-variables">Accessing environment variables</a></h2>
<p>Java provides access to environment variables via the <code>System.getenv</code> method. This method retrieves the value of an environment variable at runtime.</p>
<pre><code class="language-java">final String name = &quot;EXAMPLE_ENVIRONMENT_VARIABLE&quot;;

String value = System.getenv(name);

if (value == null || value.isEmpty()) {
    System.out.println(&quot;Environment variable '&quot; + name + &quot;' not set.&quot;);
} else {
    System.out.println(&quot;Environment variable '&quot; + name + &quot;' set to '&quot; + value + &quot;'.&quot;);
}
</code></pre>
<p>Rust provides the same functionality of accessing an environment variable at
runtime via the <code>var</code> and <code>var_os</code> functions from the <code>std::env</code> module.</p>
<p><code>var</code> function returns a <code>Result&lt;String, VarError&gt;</code>, either returning the
variable if set or returning an error if the variable is not set or it is not
valid Unicode.</p>
<p><code>var_os</code> has a different signature giving back an <code>Option&lt;OsString&gt;</code>, either
returning some value if the variable is set, or returning None if the variable
is not set. An <code>OsString</code> is not required to be valid Unicode.</p>
<pre><code class="language-rust">use std::env;


fn main() {
    let key = &quot;ExampleEnvironmentVariable&quot;;
    match env::var(key) {
        Ok(val) =&gt; println!(&quot;{key}: {val:?}&quot;),
        Err(e) =&gt; println!(&quot;couldn't interpret {key}: {e}&quot;),
    }
}</code></pre>
<pre><code class="language-rust">use std::env;

fn main() {
    let key = &quot;ExampleEnvironmentVariable&quot;;
    match env::var_os(key) {
        Some(val) =&gt; println!(&quot;{key}: {val:?}&quot;),
        None =&gt; println!(&quot;{key} not defined in the enviroment&quot;),
    }
}</code></pre>
<p>Rust also provides the functionality for accessing an environment variable at
compile time. The <code>env!</code> macro from <code>std::env</code> expands the value of the variable
at compile time, returning a <code>&amp;'static str</code>. If the variable is not set, an
error is emitted.</p>
<pre><code class="language-rust">use std::env;

fn main() {
    let example_env_variable = env!(&quot;ExampleEnvironmentVariable&quot;);
    println!(&quot;{example_env_variable}&quot;);
}</code></pre>
<p>In Java, compile time access to environment variables can be achieved, but in a
less straightforward way, using <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/package-summary.html">Reflection API</a>. Generally this is not recommended in modern Java.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Java does not have built-in support for configuration management. In order to work with configuration, we need to use third-party libraries, such as the Apache Commons Configuration library.</p>
<p>Here's the Maven dependency for the Apache Commons Configuration library that we can add to our <code>pom.xml</code> file:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-configuration2&lt;/artifactId&gt;
    &lt;version&gt;2.11.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>And here's how we can make use of the library:</p>
<pre><code class="language-java">import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.builder.fluent.Configurations;
import org.apache.commons.configuration2.ex.ConfigurationException;

public class ExampleClass {

    public static void main(String[] args) {

        Configurations configs = new Configurations();

        try {
            // Load environment variables
            Configuration configuration = configs.systemEnvironment();

            // Retrieve the value of the environment variable &quot;ExampleEnvVariable&quot;
            String exampleEnvVariable = configuration.getString(&quot;ExampleEnvVariable&quot;);

            System.out.println(exampleEnvVariable);
        } catch (ConfigurationException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>A similar configuration experience in Rust is available via use of third-party
crates such as <a href="https://crates.io/crates/figment">figment</a> or <a href="https://crates.io/crates/config">config</a>.</p>
<p>See the following example making use of the <a href="https://crates.io/crates/config">config</a> crate:</p>
<pre><code class="language-rust">use config::{Config, Environment};

fn main() {
    let builder = Config::builder().add_source(Environment::default());

    match builder.build() {
        Ok(config) =&gt; {
            match config.get_string(&quot;example_env_variable&quot;) {
                Ok(v) =&gt; println!(&quot;{v}&quot;),
                Err(e) =&gt; println!(&quot;{e}&quot;)
            }
        },
        Err(_) =&gt; {
            // something went wrong
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-tools"><a class="header" href="#build-tools">Build Tools</a></h1>
<p>The two popular build tools in the Java ecosystem are Maven and Gradle. Rust has <a href="https://doc.rust-lang.org/cargo/">Cargo</a> (<code>cargo</code>), which is both a build tool and a package manager.</p>
<p>As an example, to compile/build a project using Maven you would use <code>mvn compile</code>. The equivalent in Rust using cargo would be <code>cargo build</code>.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>To build an executable for a Java project, you can use <code>mvn package</code>, which will compile the project sources into a single executable <code>jar</code> file. The jar file can typically be run on any platform that has JVM installed. <a href="https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo-build1"><code>cargo build</code></a> in Rust does the same, except the Rust compiler statically links (although there exist other <a href="https://doc.rust-lang.org/reference/linkage.html">linking options</a>) all code into a single, platform-dependent, binary.</p>
<p>In Java, you can use a tool like <a href="https://www.graalvm.org/">GraalVM</a> to create a native binary executable, similar to what Rust does with <code>cargo build</code>.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">Crate</a></li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>In Java, the contents of the <code>pom.xml</code> file define the build options and
project dependencies. In Rust, when using Cargo, a <code>Cargo.toml</code> declares the
dependencies for a package.</p>
<p>A typical <code>pom.xml</code> file would look like:</p>
<pre><code class="language-xml">&lt;project&gt;

  &lt;groupId&gt;com.example&lt;/groupId&gt;
  &lt;artifactId&gt;simplerestapi&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;rest-api-demo&lt;/name&gt;
  &lt;description&gt;Simple REST API demo project&lt;/description&gt;

  &lt;properties&gt;
    &lt;java.version&gt;21&lt;/java.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
      &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
      &lt;version&gt;42.7.3&lt;/version&gt;
    &lt;/dependency&gt;
    ...

  &lt;/dependencies&gt;


  &lt;build&gt;
    ....
  &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>The equivalent <code>Cargo.toml</code> in Rust is defined as:</p>
<pre><code class="language-toml">[package]
name = &quot;rest-api-demo&quot;
version = &quot;0.1.0&quot;
description = &quot;Simple REST API demo project&quot;

[dependencies]
tokio = &quot;1.0.0&quot;
</code></pre>
<p>Cargo follows a convention that <code>src/main.rs</code> is the crate root of a binary
crate with the same name as the package. Likewise, Cargo knows that if the
package directory contains <code>src/lib.rs</code>, the package contains a library crate
with the same name as the package.</p>
<h2 id="package-registries"><a class="header" href="#package-registries">Package registries</a></h2>
<p>The most common package registry for Java is the <a href="https://central.sonatype.com/">Maven Central</a> repository, whereas Rust packages are usually shared via <a href="https://crates.io">crates.io</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>In Java, a standard Maven project would have the following structure:</p>
<pre><code>project directory/
.
+-- src/
|  +-- main/
|    +-- java/
|     +-- Application.java
|    +-- resources
|     +-- application.properties
|  +-- test/
|    +-- java/
|     +-- ApplicationTests.java
+-- target/
|   +-- build output files
+-- mvnw
+-- mvnw.cmd
+-- pom.xml
</code></pre>
<ul>
<li>Both Java source code and the corresponding test files are contained in the <code>src/</code> directory.</li>
<li>The <code>pom.xml</code> file and the Maven wrappers are stored at the root of the project.</li>
<li>The <code>target</code> directory contains all the build output files.</li>
</ul>
<p>Cargo uses the following conventions for the <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">package layout</a> to make it easy to
dive into a new Cargo <a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">package</a>:</p>
<pre><code>project directory/
.
+-- Cargo.lock
+-- Cargo.toml
+-- src/
|   +-- lib.rs
|   +-- main.rs
+-- benches/
|   +-- some-bench.rs
+-- examples/
|   +-- some-example.rs
+-- tests/
    +-- some-integration-test.rs
+-- target/
|   +-- build output files
</code></pre>
<ul>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of the package.</li>
<li><code>src/lib.rs</code> is the default library file, and <code>src/main.rs</code> is the default
executable file (see <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery">target auto-discovery</a>).</li>
<li>Benchmarks go in the <code>benches</code> directory, integration tests go in the <code>tests</code>
directory (see <a href="project-structure/../testing/index.html">testing</a>,
<a href="project-structure/../benchmarking/index.html">benchmarking</a>).</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>There is no separate crate for unit tests, unit tests live in the same file as
the code (see <a href="project-structure/../testing/index.html">testing</a>).</li>
</ul>
<h2 id="managing-large-projects"><a class="header" href="#managing-large-projects">Managing large projects</a></h2>
<p>For very large projects in Rust, Cargo offers <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspaces</a> to
organize the project. A workspace can help manage multiple related packages that
are developed in tandem. Some projects use <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace"><em>virtual
manifests</em></a>, especially when there is no primary
package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-programming"><a class="header" href="#meta-programming">Meta Programming</a></h1>
<p>Metaprogramming can be seen as a way of writing code that writes/generates other
code.</p>
<p>Java does not have facilities for &quot;proper&quot; metaprogramming. Instead, it offers capabilities for dynamic (runtime) introspection/reflection, mostly through the 
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/package-summary.html">Reflection API</a>.</p>
<p>Rust on the other hand has strong support for metaprogramming through a dedicated language feature: <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macros</a>. There are two main types of Rust macros: <code>declarative macros</code> and <code>procedural macros</code>.</p>
<p>Declarative macros allow you to write control structures that take an
expression, compare the resulting value of the expression to patterns, and then
run the code associated with the matching pattern. Declarative macros are also sometimes referred to as <em>macros by example</em>.</p>
<p>An example of a declarative macro is the <code>println!</code> macro that we've used quite a bit. It is used for printing some text to the standard output: <code>println!(&quot;Some text&quot;)</code>. Here's the definition for the macro:</p>
<pre><code class="language-rust">macro_rules! println {
    () =&gt; {
        $crate::print!(&quot;\n&quot;)
    };
    ($($arg:tt)*) =&gt; {{
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    }};
}</code></pre>
<p>To learn more about writing declarative macros, refer to the Rust reference
chapter <a href="https://doc.rust-lang.org/reference/macros-by-example.html">macros by example</a> or <a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a>.</p>
<p><a href="https://doc.rust-lang.org/reference/procedural-macros.html">Procedural macros</a> are different from declarative macros. Those accept some code
as an input, operate on that code, and produce some code as an output.</p>
<blockquote>
<p>Note: Rust does not support reflection.</p>
</blockquote>
<h2 id="function-like-macros"><a class="header" href="#function-like-macros">Function-like macros</a></h2>
<p>Function-like macros take the following form: <code>function!(...)</code></p>
<p>The following code snippet defines a function-like macro named
<code>print_something</code>, which is generating a <code>print_it</code> method for printing the
&quot;Something&quot; string.</p>
<p>In the <code>lib.rs</code> file:</p>
<pre><code class="language-rust">extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn print_something(_item: TokenStream) -&gt; TokenStream {
    &quot;fn print_it() { println!(\&quot;Something\&quot;) }&quot;.parse().unwrap()
}</code></pre>
<p>In the <code>main.rs</code> file:</p>
<pre><code class="language-rust">use replace_crate_name_here::print_something;
print_something!();

fn main() {
    print_it();
}</code></pre>
<h2 id="derive-macros"><a class="header" href="#derive-macros">Derive macros</a></h2>
<p>Derive macros can create new items given the token stream of a struct, enum, or
union. An example of a derive macro is the <code>#[derive(Clone)]</code>, which is generates the needed code for making the input struct/enum/union implement the <code>Clone</code> trait.</p>
<p>In order to understand how to define a custom derive macro, read the rust reference for <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros">derive macros</a>.</p>
<h2 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute macros</a></h2>
<p>Attribute macros define new attributes which can be attached to Rust items.
While working with asynchronous code, if making use of Tokio, the first step
will be to decorate the new asynchronous main with an attribute macro like in the
following example:</p>
<pre><code class="language-rust">#[tokio::main]
async fn main() {
    println!(&quot;Hello world&quot;);
}</code></pre>
<p>In order to understand how to define a custom derive macro, read the rust reference for <a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">attribute macros</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h1>
<p>Unlike Java, Rust supports the asynchronous programming model. There are different 
<em>async runtimes</em> for Rust, the most popular being <a href="https://tokio.rs/">Tokio</a>. The other options are <a href="https://async.rs/">async-std</a> and <a href="https://docs.rs/smol/latest/smol/">smol</a>.</p>
<p>Here's a simple example of how to define an asynchronous function in Rust. The example relies on <code>async-std</code> for the implementation of <code>sleep</code>:</p>
<pre><code class="language-rust">use std::time::Duration;
use async_std::task::sleep;

async fn format_delayed(message: &amp;str) -&gt; String {
    sleep(Duration::from_secs(1)).await;
    format!(&quot;Message: {}&quot;, message)
}</code></pre>
<blockquote>
<p>Note: The Rust <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> keyword transforms a block of code into a state
machine that implements the <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> trait. This allows for writing asynchronous code sequentially.</p>
</blockquote>
<p>See also:</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous programming in Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h1>
<p>As stated in the <a href="./introduction.html">introduction</a>, this guide is not meant to be a replacement for proper learning of the Rust language. Rust has great documentation and books that you can explore to continue with your journey of mastering the language.</p>
<p>Here are a few recommendations for your next steps:</p>
<ul>
<li>Check out the <a href="https://www.rust-lang.org/learn">Learn Rust</a> page of the official Rust website for excellent resources.</li>
<li><a href="https://rust-for-rustaceans.com/">Rust for Rustaceans</a>, a book by Jon Gjengset is ideal after 
becoming comfortable with the basics of the language.</li>
<li><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Programming Rust</a>, a book by Jim Blandy, et al.</li>
<li><a href="https://effective-rust.com/title-page.html">Effective Rust</a> by David Drysdale.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
